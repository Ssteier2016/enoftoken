<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Sandbox Arena - Multijugador</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <style>
        /* ============================
           ESTILOS GENERALES Y RESET
        ============================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        :root {
            --primary: #dc2626;
            --secondary: #1e293b;
            --accent: #fbbf24;
            --dark: #0f172a;
            --light: #f8fafc;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --premium: #8b5cf6;
            --player1: #3b82f6;
            --player2: #10b981;
            --player3: #8b5cf6;
            --player4: #f59e0b;
        }

        body {
            background: linear-gradient(135deg, var(--dark) 0%, var(--secondary) 100%);
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
            touch-action: manipulation;
            overflow: hidden;
        }

        /* ============================
           PANTALLA DE INICIO
        ============================ */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-image: url('caratula.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            padding: 1rem;
        }

        .start-title {
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-align: center;
            background: linear-gradient(to right, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 30px rgba(220, 38, 38, 0.3);
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .start-title {
                font-size: 2.5rem;
            }
        }

        .start-button {
            background: linear-gradient(135deg, var(--primary), var(--danger));
            color: white;
            border: none;
            padding: 1rem 3rem;
            border-radius: 12px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            box-shadow: 0 10px 25px rgba(220, 38, 38, 0.3);
            animation: pulse 2s infinite;
        }

        @media (max-width: 768px) {
            .start-button {
                padding: 0.8rem 2rem;
                font-size: 1.2rem;
            }
        }

        .start-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(220, 38, 38, 0.4);
        }

        /* ============================
           MEN√ö PRINCIPAL
        ============================ */
        #main-menu, #game-screen, #editor-screen, #character-select, #multiplayer-screen {
            display: none;
            min-height: 100vh;
            padding: 1rem;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            #main-menu, #game-screen, #editor-screen, #character-select, #multiplayer-screen {
                padding: 0.5rem;
            }
            
            .header {
                margin-bottom: 1.5rem !important;
            }
            
            .game-title {
                font-size: 2.5rem !important;
            }
            
            .subtitle {
                font-size: 1rem !important;
            }
            
            .stats-container {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
                margin: 1rem 0 !important;
            }
            
            .stat-box {
                min-width: 100% !important;
                padding: 1rem !important;
                margin-bottom: 0.5rem;
            }
        }

        .screen-active {
            display: block !important;
            animation: slideUp 0.5s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            position: relative;
        }

        .header:hover .game-title {
            transform: scale(1.02);
        }

        .game-title {
            font-size: 4rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 1rem;
            background: linear-gradient(to right, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 30px rgba(220, 38, 38, 0.3);
            transition: transform 0.3s ease;
            display: inline-block;
            cursor: pointer;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #94a3b8;
            margin-bottom: 2rem;
        }

        .menu-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 768px) {
            .menu-options {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .menu-card {
                padding: 1.5rem !important;
                margin-bottom: 1rem;
            }
            
            .menu-icon {
                width: 60px !important;
                height: 60px !important;
                font-size: 1.8rem !important;
            }
            
            .menu-card h2 {
                font-size: 1.4rem !important;
            }
        }

        .menu-card {
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 2.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .menu-card:hover {
            transform: translateY(-10px);
            border-color: var(--primary);
            box-shadow: 0 20px 40px rgba(220, 38, 38, 0.2);
        }

        .menu-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--primary), var(--danger));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1.5rem;
            font-size: 2.5rem;
        }

        .menu-card h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        .menu-card p {
            color: #94a3b8;
            line-height: 1.6;
        }

        /* ============================
           CARRUSEL DE PERSONAJES
        ============================ */
        .character-carousel-container {
            position: relative;
            max-width: 900px;
            margin: 1rem auto 2rem;
            overflow: hidden;
            border-radius: 20px;
            background: rgba(15, 23, 42, 0.8);
            padding: 1rem;
            touch-action: pan-y pinch-zoom;
        }

        @media (max-width: 768px) {
            .character-carousel-container {
                padding: 0.5rem;
                margin: 0.5rem auto 1rem;
                border-radius: 15px;
            }
            
            .carousel-arrow {
                width: 40px !important;
                height: 40px !important;
                font-size: 1rem !important;
            }
            
            .carousel-arrow.prev {
                left: 5px !important;
            }
            
            .carousel-arrow.next {
                right: 5px !important;
            }
            
            .character-carousel-preview {
                width: 120px !important;
                height: 120px !important;
            }
        }

        .character-carousel {
            display: flex;
            transition: transform 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
            gap: 0;
            width: 100%;
        }

        .character-carousel-item {
            flex: 0 0 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            transition: all 0.4s ease;
            opacity: 0.5;
            transform: scale(0.9);
        }

        .character-carousel-item.active {
            opacity: 1;
            transform: scale(1.05);
        }

        .character-carousel-preview {
            width: 200px;
            height: 200px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
        }

        .character-carousel-item.active .character-carousel-preview {
            transform: scale(1.1);
            filter: drop-shadow(0 10px 25px rgba(251, 191, 36, 0.5));
        }

        .character-carousel-info {
            text-align: center;
            max-width: 500px;
            padding: 0 1rem;
        }

        .character-carousel-info h3 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: var(--accent);
        }

        .character-carousel-description {
            color: #94a3b8;
            margin-bottom: 1rem;
            line-height: 1.5;
            font-size: 1rem;
        }

        .character-carousel-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(30, 41, 59, 0.7);
            border-radius: 10px;
        }

        .carousel-stat {
            text-align: center;
        }

        .carousel-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
        }

        .carousel-stat-label {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .carousel-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            justify-content: center;
        }

        .carousel-arrow {
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }

        .carousel-arrow:hover {
            background: var(--primary);
            border-color: var(--primary);
            transform: translateY(-50%) scale(1.1);
        }

        .carousel-arrow.prev {
            left: 20px;
        }

        .carousel-arrow.next {
            right: 20px;
        }

        .carousel-indicators {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .carousel-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .carousel-indicator.active {
            background: var(--primary);
            transform: scale(1.2);
        }

        /* ============================
           MULTIJUGADOR
        ============================ */
        .multiplayer-rooms {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .room-card {
            background: rgba(30, 41, 59, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .room-card:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
        }

        .room-card.full {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .room-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .room-players {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .player-slot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .player-slot.occupied {
            background: var(--primary);
        }

        .room-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* ============================
           JOYSTICK VIRTUAL MEJORADO
        ============================ */
        #joystick-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 180px;
            height: 180px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            z-index: 100;
            backdrop-filter: blur(10px);
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            #joystick-container {
                width: 160px;
                height: 160px;
                bottom: 25px;
                left: 25px;
            }
        }

        #joystick-knob {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at 30% 30%, var(--primary), #7f1d1d);
            border-radius: 50%;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            cursor: pointer;
            position: absolute;
            z-index: 10;
            border: 3px solid rgba(251, 191, 36, 0.5);
            transition: transform 0.1s ease;
        }

        @media (max-width: 768px) {
            #joystick-knob {
                width: 80px;
                height: 80px;
            }
        }

        /* Direcciones del joystick */
        .joystick-directions {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .joystick-direction {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 1.2rem;
        }

        .joystick-up { top: 10px; left: 50%; transform: translateX(-50%); }
        .joystick-down { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .joystick-left { left: 10px; top: 50%; transform: translateY(-50%); }
        .joystick-right { right: 10px; top: 50%; transform: translateY(-50%); }

        /* ============================
           HUD DEL JUEGO
        ============================ */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            background: rgba(15, 23, 42, 0.95);
            padding: 0.75rem 1.5rem;
            backdrop-filter: blur(15px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            height: 70px;
        }

        @media (max-width: 768px) {
            .hud {
                padding: 0.5rem 1rem;
                height: 60px;
                flex-wrap: wrap;
            }
            
            .hud-section {
                gap: 0.5rem !important;
            }
            
            .hud-item {
                gap: 0.25rem !important;
            }
        }

        .hud-section {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hud-icon {
            font-size: 1.5rem;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hud-value {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .hud-label {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-right: 0.25rem;
        }

        /* Indicador de multijugador */
        .multiplayer-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 20px;
            border: 1px solid var(--player1);
        }

        .player-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .player-1 .player-color { background: var(--player1); }
        .player-2 .player-color { background: var(--player2); }
        .player-3 .player-color { background: var(--player3); }
        .player-4 .player-color { background: var(--player4); }

        /* ============================
           BOTONES DE ACCI√ìN
        ============================ */
        .game-action-buttons {
            position: fixed;
            top: 80px;
            right: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .game-action-buttons {
                top: 70px;
                right: 1rem;
            }
        }

        .game-action-btn {
            width: 55px;
            height: 55px;
            background: rgba(30, 41, 59, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            .game-action-btn {
                width: 50px;
                height: 50px;
                font-size: 1.4rem;
            }
        }

        .game-action-btn:hover {
            border-color: var(--primary);
            background: rgba(220, 38, 38, 0.3);
            transform: scale(1.1);
        }

        /* ============================
           BOT√ìN DE DISPARO T√ÅCTIL
        ============================ */
        #touch-shoot-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--danger), #7f1d1d);
            border: 3px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            font-size: 2.2rem;
            color: white;
            cursor: pointer;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.4);
            transition: all 0.1s ease;
        }

        @media (max-width: 768px) {
            #touch-shoot-btn {
                width: 80px;
                height: 80px;
                bottom: 25px;
                right: 25px;
                font-size: 2rem;
            }
        }

        #touch-shoot-btn.active {
            display: flex;
        }

        #touch-shoot-btn:active {
            transform: scale(0.9);
            background: radial-gradient(circle at 30% 30%, #dc2626, #450a0a);
            box-shadow: 0 15px 40px rgba(239, 68, 68, 0.7);
        }

        /* ============================
           TABLERO DE JUEGO
        ============================ */
        .game-board-container {
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            z-index: 1;
            touch-action: pinch-zoom pan-x pan-y;
            background: #0a1128;
        }

        @media (max-width: 768px) {
            .game-board-container {
                top: 60px;
            }
        }

        .game-board {
            display: grid;
            gap: 0px;
            background: rgba(0, 0, 0, 0.3);
            position: absolute;
            transform-origin: 0 0;
            transition: transform 0.1s ease;
            justify-content: center;
            align-content: center;
            width: 100%;
            height: 100%;
        }

        .game-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s ease;
            background-size: cover;
            background-position: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            border: 0.5px solid rgba(255, 255, 255, 0.05);
            width: 100%;
            height: 100%;
        }

        /* Estilos de celdas */
        .cell-empty { background-color: #1e293b; }
        .cell-wall { background-color: #92400e; }
        .cell-zombie { background-color: #7f1d1d; }
        .cell-rock { background-color: #475569; }
        .cell-box { background-color: #854d0e; }
        .cell-grass { background-color: #166534; }
        .cell-water { background-color: #1d4ed8; }
        .cell-rifle { background-color: #374151; }
        .cell-shotgun { background-color: #525252; }
        .cell-key { background-color: #ca8a04; }
        .cell-portal { background-color: #7c3aed; }
        .cell-start { background-color: #059669; }
        .cell-exit { background-color: #dc2626; }
        .cell-door { background-color: #7c2d12; }
        .cell-coin { background-color: #eab308; }
        .cell-bomb { background-color: #831843; }
        .cell-sword { background-color: #1e40af; }
        .cell-cactus { background-color: #166534; }
        .cell-bullet { background-color: #374151; }
        .cell-ammo { background-color: #525252; }
        .cell-palanca { background-color: #7c2d12; }
        .cell-vacuna { background-color: #10b981; }
        .cell-zombierambo { background-color: #450a0a; }

        /* Jugadores multijugador */
        .player-1-cell {
            animation: pulse 1.5s infinite;
            border: 2px solid var(--player1);
            box-shadow: 0 0 10px var(--player1);
        }

        .player-2-cell {
            animation: pulse 1.5s infinite;
            border: 2px solid var(--player2);
            box-shadow: 0 0 10px var(--player2);
        }

        .player-3-cell {
            animation: pulse 1.5s infinite;
            border: 2px solid var(--player3);
            box-shadow: 0 0 10px var(--player3);
        }

        .player-4-cell {
            animation: pulse 1.5s infinite;
            border: 2px solid var(--player4);
            box-shadow: 0 0 10px var(--player4);
        }

        .zombie-cell {
            position: relative;
            animation: zombieMove 2s infinite alternate;
        }

        /* BARRA DE SALUD */
        .health-bar-container {
            position: absolute;
            bottom: -5px;
            left: 5px;
            right: 5px;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #fbbf24, #ef4444);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* ============================
           MODALES Y MENSAJES
        ============================ */
        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.98);
            padding: 2rem 3rem;
            border-radius: 25px;
            text-align: center;
            z-index: 1000;
            border: 3px solid var(--primary);
            box-shadow: 0 20px 60px rgba(220, 38, 38, 0.4);
            animation: popIn 0.3s ease;
            min-width: 350px;
            max-width: 90%;
            display: none;
            backdrop-filter: blur(20px);
        }

        @media (max-width: 768px) {
            .message {
                padding: 1.5rem 2rem;
                min-width: 280px;
            }
        }

        .message.active {
            display: block;
        }

        .message h2 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .message p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            color: #cbd5e1;
            line-height: 1.6;
        }

        .message-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--primary), var(--danger));
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            margin: 0.5rem;
        }

        .message-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(220, 38, 38, 0.4);
        }

        /* ============================
           EDITOR DE NIVELES
        ============================ */
        .editor-action-buttons {
            position: fixed;
            top: 15px;
            left: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            z-index: 100;
        }

        .editor-action-btn {
            background: rgba(30, 41, 59, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            backdrop-filter: blur(10px);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .editor-action-btn:hover {
            border-color: var(--primary);
            background: rgba(220, 38, 38, 0.3);
            transform: translateY(-2px);
        }

        .editor-tools {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
            margin: 1rem 0;
            max-height: 250px;
            overflow-y: auto;
            padding: 1rem;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 15px;
        }

        .tool-btn {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 0.75rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tool-btn.active {
            border-color: var(--accent);
            background: rgba(251, 191, 36, 0.25);
            transform: scale(1.05);
        }

        .tool-btn:hover {
            transform: scale(1.05);
            border-color: var(--primary);
        }

        .tool-preview {
            width: 60px;
            height: 60px;
            margin: 0 auto 0.5rem;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* ============================
           ESTAD√çSTICAS Y HIGHSCORE
        ============================ */
        .stats-container {
            display: flex;
            justify-content: space-around;
            margin: 2rem 0;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .stat-box {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 15px;
            padding: 1.5rem 2rem;
            text-align: center;
            min-width: 220px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .stat-box:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
        }

        .stat-number {
            font-size: 2.8rem;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }

        .stat-label-large {
            font-size: 1.1rem;
            color: #94a3b8;
            font-weight: 500;
        }

        /* Highscore */
        .highscore-container {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 20px;
            padding: 1.5rem;
            margin: 2rem auto;
            max-width: 900px;
            overflow-x: auto;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .highscore-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 1rem;
        }

        .highscore-table th {
            background: rgba(15, 23, 42, 0.9);
            padding: 1rem;
            text-align: left;
            color: var(--accent);
            border-bottom: 3px solid var(--primary);
            white-space: nowrap;
            font-weight: 600;
        }

        .highscore-table td {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .highscore-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .highscore-rank {
            width: 70px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .highscore-name {
            font-weight: bold;
        }

        .highscore-score {
            color: var(--accent);
            font-weight: bold;
            text-align: right;
            font-size: 1.1rem;
        }

        /* ============================
           ANIMACIONES
        ============================ */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes zombieMove {
            0% { transform: translateX(-1px) rotate(-1deg); }
            100% { transform: translateX(1px) rotate(1deg); }
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.7); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        @keyframes slideUp {
            0% { transform: translateY(100px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        @keyframes joystickPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
        }

        /* ============================
           UTILIDADES
        ============================ */
        .hidden {
            display: none !important;
        }

        .visible {
            display: block !important;
        }

        .text-center {
            text-align: center;
        }

        .mb-1 { margin-bottom: 0.5rem; }
        .mb-2 { margin-bottom: 1rem; }
        .mb-3 { margin-bottom: 1.5rem; }
        .mb-4 { margin-bottom: 2rem; }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--danger));
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        /* Monedas */
        .coins-display {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.6rem;
            font-weight: bold;
            color: #eab308;
            margin-bottom: 1.5rem;
            justify-content: center;
            text-shadow: 0 0 10px rgba(234, 179, 8, 0.3);
        }

        .coins-display img {
            width: 36px;
            height: 36px;
            filter: drop-shadow(0 0 5px rgba(234, 179, 8, 0.5));
        }

        /* Scrollbar personalizada */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--danger);
        }

        /* Indicador de carga */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Notificaciones */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 41, 59, 0.95);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border-left: 4px solid var(--accent);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: none;
            animation: slideInRight 0.3s ease;
            max-width: 350px;
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .notification.active {
            display: block;
        }

        .notification-success {
            border-left-color: var(--success);
        }

        .notification-error {
            border-left-color: var(--danger);
        }

        .notification-info {
            border-left-color: var(--player1);
        }
    </style>
</head>
<body>
    <!-- Overlay de carga -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="text-center">
            <div class="spinner"></div>
            <p id="loading-text" style="color: #94a3b8; margin-top: 1rem;">Cargando...</p>
        </div>
    </div>

    <!-- Notificaciones -->
    <div id="notification" class="notification">
        <p id="notification-text"></p>
    </div>

    <!-- Pantalla de inicio -->
    <div id="start-screen">
        <div class="start-overlay">
            <h1 class="start-title">SANDBOX ARENA</h1>
            <button class="start-button" onclick="startGameFromHome()">
                <i class="fas fa-play"></i> EMPEZAR
            </button>
        </div>
    </div>

    <!-- Modal para nickname -->
    <div id="nickname-modal" class="message">
        <h2 class="text-center mb-2">¬°BIENVENIDO!</h2>
        <p class="text-center mb-3" style="color: #94a3b8;">
            Ingresa tu nickname para aparecer en el Highscore y jugar en multijugador
        </p>
        <input type="text" id="nickname-input" class="nickname-input" 
               placeholder="Tu nickname" maxlength="20" style="
                   width: 100%;
                   padding: 1rem;
                   margin: 1rem 0;
                   background: rgba(15, 23, 42, 0.7);
                   border: 2px solid rgba(255, 255, 255, 0.1);
                   border-radius: 10px;
                   color: white;
                   font-size: 1.2rem;
                   text-align: center;
               ">
        <div class="text-center mt-3">
            <button class="btn btn-primary" onclick="saveNickname()">
                <i class="fas fa-save"></i> Guardar y Jugar
            </button>
        </div>
    </div>

    <!-- Men√∫ principal -->
    <div id="main-menu" class="container">
        <div class="header">
            <h1 class="game-title" onclick="countTitleClicks()">SANDBOX ARENA</h1>
            <p class="subtitle">Supervivencia ‚Ä¢ Construcci√≥n ‚Ä¢ Multijugador</p>
            
            <!-- Mostrar monedas obtenidas -->
            <div class="coins-display">
                <img src="moneda.png" alt="Monedas" onerror="this.parentElement.innerHTML='üí∞ <span id=\"total-coins-display\">0</span>'">
                <span id="total-coins-display">0</span>
            </div>
        </div>

        <div class="stats-container">
            <div class="stat-box">
                <div class="stat-number" id="highscore-coins">0</div>
                <div class="stat-label-large">M√°ximo de Monedas</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="total-levels">0</div>
                <div class="stat-label-large">Niveles Completados</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="total-zombies">0</div>
                <div class="stat-label-large">Zombies Eliminados</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="friends-online">0</div>
                <div class="stat-label-large">Amigos Conectados</div>
            </div>
        </div>

        <!-- Opciones del men√∫ -->
        <div class="menu-options">
            <div class="menu-card" onclick="showScreen('character-select')">
                <div class="menu-icon" style="background: linear-gradient(135deg, var(--primary), var(--warning));">
                    <i class="fas fa-gamepad"></i>
                </div>
                <h2>Modo Jugador</h2>
                <p>Sobrevive a los niveles creados. ¬°Elige tu personaje y lucha por tu vida!</p>
            </div>

            <div class="menu-card" onclick="showScreen('multiplayer-screen')">
                <div class="menu-icon" style="background: linear-gradient(135deg, var(--player1), var(--player3));">
                    <i class="fas fa-users"></i>
                </div>
                <h2>Multijugador</h2>
                <p>Juega con amigos en tiempo real. Crea salas y compite juntos.</p>
            </div>

            <div class="menu-card" onclick="showScreen('editor-screen')">
                <div class="menu-icon" style="background: linear-gradient(135deg, var(--success), var(--player2));">
                    <i class="fas fa-brain"></i>
                </div>
                <h2>Modo Cerebro</h2>
                <p>Dise√±a tus propios escenarios de supervivencia con bloques. Crea desaf√≠os mortales.</p>
            </div>

            <div class="menu-card" onclick="loadLevelsModal()">
                <div class="menu-icon" style="background: linear-gradient(135deg, var(--premium), #c084fc);">
                    <i class="fas fa-list"></i>
                </div>
                <h2>Niveles Guardados</h2>
                <p>Gestiona tus niveles personalizados. Edita, elimina o juega tus creaciones.</p>
            </div>
        </div>

        <!-- CARRUSEL DE PERSONAJES -->
        <div class="character-carousel-container" id="carousel-container">
            <div class="carousel-arrow prev" onclick="previousCharacter()">
                <i class="fas fa-chevron-left"></i>
            </div>
            <div class="carousel-arrow next" onclick="nextCharacter()">
                <i class="fas fa-chevron-right"></i>
            </div>
            
            <div class="character-carousel" id="character-carousel">
                <!-- Los personajes se cargar√°n aqu√≠ din√°micamente -->
            </div>
            
            <div class="carousel-indicators" id="carousel-indicators">
                <!-- Los indicadores se generar√°n din√°micamente -->
            </div>
        </div>

        <div class="text-center mb-4">
            <p class="subtitle">Selecciona un personaje para comenzar la aventura</p>
            <div class="play-button-container">
                <button class="play-button" onclick="startGameFromMenu()">
                    <i class="fas fa-play-circle"></i> JUGAR SOLO
                </button>
                <button class="play-button" onclick="createMultiplayerRoom()" style="background: linear-gradient(135deg, var(--player1), var(--player3)); margin-left: 1rem;">
                    <i class="fas fa-users"></i> CREAR SALA
                </button>
            </div>
        </div>

        <!-- Tabla de highscore -->
        <div class="highscore-container">
            <h2 class="text-center mb-2">üèÜ Highscore Global</h2>
            <div id="highscore-loading" class="text-center">
                <p>Cargando puntajes...</p>
            </div>
            <table class="highscore-table" id="highscore-table">
                <thead>
                    <tr>
                        <th class="highscore-rank">#</th>
                        <th>Jugador</th>
                        <th>Personaje</th>
                        <th>Nivel</th>
                        <th class="highscore-score">Puntaje</th>
                        <th>Fecha</th>
                    </tr>
                </thead>
                <tbody id="highscore-body">
                    <!-- Los puntajes se cargar√°n aqu√≠ -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Pantalla multijugador -->
    <div id="multiplayer-screen" class="container">
        <div class="header">
            <h1 class="game-title">MULTIJUGADOR</h1>
            <p class="subtitle">Juega con amigos en tiempo real</p>
        </div>

        <div class="action-buttons" style="display: flex; gap: 1rem; justify-content: center; margin-bottom: 2rem;">
            <button class="btn btn-primary" onclick="createMultiplayerRoom()">
                <i class="fas fa-plus"></i> Crear Sala
            </button>
            <button class="btn btn-secondary" onclick="refreshRooms()">
                <i class="fas fa-sync-alt"></i> Actualizar
            </button>
            <button class="btn btn-secondary" onclick="showScreen('main-menu')">
                <i class="fas fa-arrow-left"></i> Volver
            </button>
        </div>

        <div id="multiplayer-rooms" class="multiplayer-rooms">
            <!-- Las salas se cargar√°n aqu√≠ din√°micamente -->
        </div>

        <div id="no-rooms-message" class="text-center" style="display: none;">
            <p style="color: #94a3b8; margin-bottom: 2rem;">No hay salas disponibles. ¬°Crea una!</p>
        </div>
    </div>

    <!-- Editor de niveles -->
    <div id="editor-screen">
        <div class="editor-action-buttons">
            <button class="editor-action-btn" onclick="saveLevel()">
                <i class="fas fa-save"></i> Guardar
            </button>
            <button class="editor-action-btn" onclick="createNewLevel()">
                <i class="fas fa-plus"></i> Nuevo
            </button>
            <button class="editor-action-btn" onclick="loadLevelsModal()">
                <i class="fas fa-list"></i> Niveles
            </button>
            <button class="editor-action-btn" onclick="playCurrentLevel()">
                <i class="fas fa-play"></i> Probar
            </button>
            <button class="editor-action-btn" onclick="showScreen('main-menu')">
                <i class="fas fa-home"></i> Men√∫
            </button>
        </div>

        <div class="container">
            <div class="header">
                <h1 class="game-title">MODO CEREBRO</h1>
                <p class="subtitle">Dise√±a tu propio nivel de supervivencia</p>
            </div>

            <div class="editor-config" style="background: rgba(30, 41, 59, 0.6); border-radius: 15px; padding: 1.5rem; margin-bottom: 2rem;">
                <h3 class="text-center mb-2">Configuraci√≥n del Nivel</h3>
                <div class="config-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin-bottom: 1rem;">
                    <div class="config-item">
                        <label class="setting-label">Tama√±o del Tablero:</label>
                        <select id="editor-board-size" class="config-input" onchange="updateEditorSize()" style="
                            width: 100%;
                            padding: 0.75rem;
                            background: rgba(15, 23, 42, 0.7);
                            border: 2px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            color: white;
                            font-size: 1rem;
                        ">
                            <option value="10">10x10</option>
                            <option value="12">12x12</option>
                            <option value="15">15x15</option>
                            <option value="20">20x20</option>
                        </select>
                    </div>
                    <div class="config-item">
                        <label class="setting-label">Tiempo (segundos):</label>
                        <input type="number" id="editor-time" class="config-input" value="120" min="30" max="600" style="
                            width: 100%;
                            padding: 0.75rem;
                            background: rgba(15, 23, 42, 0.7);
                            border: 2px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            color: white;
                            font-size: 1rem;
                        ">
                    </div>
                </div>
                <div class="config-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                    <div class="config-item">
                        <label class="setting-label">N√∫mero de Nivel:</label>
                        <input type="number" id="editor-level-number" class="config-input" value="1" min="1" max="100" style="
                            width: 100%;
                            padding: 0.75rem;
                            background: rgba(15, 23, 42, 0.7);
                            border: 2px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            color: white;
                            font-size: 1rem;
                        ">
                    </div>
                    <div class="config-item">
                        <label class="setting-label">Nombre del Nivel:</label>
                        <input type="text" id="editor-level-name-input" class="config-input" value="Mi Nivel Personalizado" style="
                            width: 100%;
                            padding: 0.75rem;
                            background: rgba(15, 23, 42, 0.7);
                            border: 2px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            color: white;
                            font-size: 1rem;
                        ">
                    </div>
                </div>
            </div>

            <div class="editor-tools" id="editor-tools">
                <!-- Las herramientas se cargar√°n aqu√≠ -->
            </div>

            <div class="editor-board-container" style="position: relative; width: 100%; min-height: 500px; background: rgba(0, 0, 0, 0.3); border-radius: 15px; overflow: auto; padding: 1.5rem; margin-top: 1rem;">
                <div class="editor-board" id="editor-board" style="display: grid; gap: 0px; margin: 0 auto; background: rgba(30, 41, 59, 0.5); padding: 5px; border-radius: 5px;">
                    <!-- El tablero del editor se generar√° aqu√≠ -->
                </div>
            </div>
        </div>
    </div>

    <!-- Pantalla de juego -->
    <div id="game-screen">
        <!-- Overlay de pausa -->
        <div class="pause-overlay" id="pause-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: none; justify-content: center; align-items: center; z-index: 1001;">
            <div class="pause-content" style="background: rgba(15, 23, 42, 0.95); padding: 2.5rem; border-radius: 25px; text-align: center; border: 3px solid var(--primary); max-width: 90%;">
                <h2 style="color: var(--accent); margin-bottom: 1rem; font-size: 2.5rem;">JUEGO EN PAUSA</h2>
                <p style="margin-bottom: 2rem; color: #cbd5e1; font-size: 1.2rem;">¬øQu√© quieres hacer?</p>
                <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="resumeGame()">
                        <i class="fas fa-play"></i> Continuar
                    </button>
                    <button class="btn btn-secondary" onclick="showScreen('main-menu')">
                        <i class="fas fa-home"></i> Men√∫ Principal
                    </button>
                    <button class="btn btn-secondary" onclick="toggleFullscreen()">
                        <i class="fas fa-expand"></i> Pantalla Completa
                    </button>
                </div>
            </div>
        </div>

        <!-- HUD superior -->
        <div class="hud">
            <div class="hud-section">
                <div class="hud-item">
                    <div class="health-bar-container">
                        <div id="health-bar" class="health-bar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="hud-item">
                    <i class="fas fa-heart hud-icon" style="color: #ef4444;"></i>
                    <span class="hud-label">Salud:</span>
                    <span id="health" class="hud-value">100</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-user hud-icon" style="color: #3b82f6;"></i>
                    <span id="character-name" class="hud-value">Civil</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-trophy hud-icon" style="color: #eab308;"></i>
                    <span class="hud-label">Nivel:</span>
                    <span id="current-level" class="hud-value">1</span>
                </div>
                <div class="hud-item">
                    <div class="coin-price">
                        <img src="moneda.png" alt="Monedas" onerror="this.parentElement.innerHTML='üí∞ <span id=\"coins\" class=\"hud-value\">0</span>'" style="width: 24px; height: 24px;">
                        <span id="coins" class="hud-value">0</span>
                    </div>
                </div>
            </div>
            <div class="hud-section">
                <div class="hud-item">
                    <i class="fas fa-gun hud-icon" style="color: #94a3b8;"></i>
                    <span class="hud-label">Balas:</span>
                    <span id="shots" class="hud-value">0/0</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-key hud-icon" style="color: #eab308;"></i>
                    <span class="hud-label">Llaves:</span>
                    <span id="keys" class="hud-value">0</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-bomb hud-icon" style="color: #dc2626;"></i>
                    <span class="hud-label">Bombas:</span>
                    <span id="bombs" class="hud-value">0</span>
                </div>
                <div class="hud-item">
                    <i class="fas fa-clock hud-icon" style="color: #f59e0b;"></i>
                    <span class="hud-label">Tiempo:</span>
                    <span id="time" class="hud-value">120</span>
                </div>
                <!-- Indicador de multijugador -->
                <div id="multiplayer-hud" class="multiplayer-indicator" style="display: none;">
                    <i class="fas fa-users" style="color: var(--player1);"></i>
                    <div class="player-indicator player-1">
                        <div class="player-color"></div>
                        <span id="player1-name" class="hud-value">T√∫</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Botones de acci√≥n en juego -->
        <div class="game-action-buttons">
            <button class="game-action-btn" onclick="togglePause()" title="Pausar">
                <i class="fas fa-pause"></i>
            </button>
            <button class="game-action-btn" onclick="toggleInventory()" title="Inventario">
                <i class="fas fa-backpack"></i>
            </button>
            <button class="game-action-btn" onclick="useBomb()" title="Usar Bomba">
                <i class="fas fa-bomb"></i>
            </button>
            <button class="game-action-btn" onclick="showScreen('main-menu')" title="Salir">
                <i class="fas fa-sign-out-alt"></i>
            </button>
        </div>

        <!-- JOYSTICK VIRTUAL -->
        <div id="joystick-container">
            <div class="joystick-directions">
                <div class="joystick-direction joystick-up"><i class="fas fa-chevron-up"></i></div>
                <div class="joystick-direction joystick-down"><i class="fas fa-chevron-down"></i></div>
                <div class="joystick-direction joystick-left"><i class="fas fa-chevron-left"></i></div>
                <div class="joystick-direction joystick-right"><i class="fas fa-chevron-right"></i></div>
            </div>
        </div>
        <div id="joystick-knob"></div>

        <!-- Bot√≥n de disparo t√°ctil -->
        <div id="touch-shoot-btn">
            <i class="fas fa-burst"></i>
        </div>

        <!-- Contenedor del tablero de juego -->
        <div class="game-board-container" id="game-board-container">
            <div class="game-board" id="game-board">
                <!-- El tablero de juego se generar√° aqu√≠ -->
            </div>
        </div>

        <!-- Ventana de inventario -->
        <div class="inventory-modal" id="inventory-modal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 95%; max-width: 500px; max-height: 80vh; background: rgba(15, 23, 42, 0.95); border: 2px solid var(--accent); border-radius: 20px; padding: 1.5rem; z-index: 1000; backdrop-filter: blur(20px); display: none; overflow-y: auto;">
            <div class="inventory-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h2>Inventario</h2>
                <button class="btn btn-secondary" onclick="toggleInventory()">
                    <i class="fas fa-times"></i> Cerrar
                </button>
            </div>
            <div class="inventory-items" id="inventory-items" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 1rem;">
                <!-- Los items del inventario se cargar√°n aqu√≠ -->
            </div>
        </div>

        <!-- Selector de bomba -->
        <div class="bomb-selector" id="bomb-selector" style="position: fixed; bottom: 150px; right: 2rem; background: rgba(30, 41, 59, 0.9); padding: 1rem; border-radius: 10px; display: none; z-index: 99; border: 2px solid var(--warning);">
            <p>Bomba lista para soltar</p>
            <button class="bomb-btn" onclick="placeBomb()" style="background: var(--warning); color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer; margin-top: 0.5rem; display: block; width: 100%;">Soltar Bomba</button>
            <button class="bomb-btn" onclick="cancelBomb()" style="background: #6b7280; color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer; margin-top: 0.5rem; display: block; width: 100%;">Cancelar</button>
        </div>

        <!-- Overlay para controles t√°ctiles -->
        <div class="touch-controls-overlay" id="touch-controls-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 90; display: none; touch-action: manipulation;"></div>
    </div>

    <!-- Mensajes y modales -->
    <div id="message-modal" class="message">
        <h2 id="message-title">¬°Victoria!</h2>
        <p id="message-text">Has completado el nivel con √©xito.</p>
        <button id="message-button" class="message-btn" onclick="hideMessage()">Continuar</button>
    </div>

    <!-- Modal de niveles -->
    <div id="levels-modal" class="message">
        <h2>Niveles Guardados</h2>
        <div class="level-filters" style="display: flex; gap: 0.5rem; margin-bottom: 1rem; justify-content: center;">
            <button class="filter-btn active" onclick="filterLevels('all')" style="padding: 0.5rem 1rem; background: rgba(30, 41, 59, 0.7); border: 2px solid rgba(255, 255, 255, 0.1); border-radius: 20px; color: white; cursor: pointer; transition: all 0.2s ease;">Todos</button>
            <button class="filter-btn" onclick="filterLevels('custom')" style="padding: 0.5rem 1rem; background: rgba(30, 41, 59, 0.7); border: 2px solid rgba(255, 255, 255, 0.1); border-radius: 20px; color: white; cursor: pointer; transition: all 0.2s ease;">Personalizados</button>
        </div>
        
        <div id="levels-list" class="levels-list" style="max-height: 300px; overflow-y: auto; margin: 1rem 0;">
            <!-- Los niveles se cargar√°n aqu√≠ -->
        </div>
        <div class="text-center mt-3">
            <button class="btn btn-secondary" onclick="hideMessage()">
                <i class="fas fa-times"></i> Cerrar
            </button>
        </div>
    </div>

    <!-- Modal de sala multijugador -->
    <div id="room-modal" class="message">
        <h2 id="room-title">Crear Sala</h2>
        <div style="margin: 1.5rem 0;">
            <label style="display: block; margin-bottom: 0.5rem; color: #94a3b8;">Nombre de la sala:</label>
            <input type="text" id="room-name-input" class="nickname-input" placeholder="Nombre de la sala" maxlength="30" style="
                width: 100%;
                padding: 1rem;
                margin: 0.5rem 0;
                background: rgba(15, 23, 42, 0.7);
                border: 2px solid rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                color: white;
                font-size: 1.1rem;
            ">
            <label style="display: block; margin: 1rem 0 0.5rem; color: #94a3b8;">Nivel a jugar:</label>
            <select id="room-level-select" class="config-input" style="
                width: 100%;
                padding: 1rem;
                background: rgba(15, 23, 42, 0.7);
                border: 2px solid rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                color: white;
                font-size: 1.1rem;
            ">
                <!-- Los niveles se cargar√°n aqu√≠ -->
            </select>
            <label style="display: block; margin: 1rem 0 0.5rem; color: #94a3b8;">M√°ximo de jugadores:</label>
            <select id="room-max-players" class="config-input" style="
                width: 100%;
                padding: 1rem;
                background: rgba(15, 23, 42, 0.7);
                border: 2px solid rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                color: white;
                font-size: 1.1rem;
            ">
                <option value="2">2 Jugadores</option>
                <option value="3">3 Jugadores</option>
                <option value="4">4 Jugadores</option>
            </select>
        </div>
        <div id="room-players-list" style="margin: 1.5rem 0;">
            <!-- Lista de jugadores se cargar√° aqu√≠ -->
        </div>
        <div id="room-buttons">
            <button class="message-btn" onclick="startMultiplayerGame()" id="start-room-btn">
                <i class="fas fa-play"></i> Iniciar Juego
            </button>
            <button class="message-btn" onclick="leaveRoom()" id="leave-room-btn" style="background: #6b7280;">
                <i class="fas fa-sign-out-alt"></i> Salir
            </button>
        </div>
    </div>

    <script>
        // ============================
        // CONFIGURACI√ìN DE FIREBASE
        // ============================
        const firebaseConfig = {
            apiKey: "AIzaSyDM9GK7_gnd0GaVbxwK9xnwl0qk75MnFXw",
            authDomain: "playmobil-2d74d.firebaseapp.com",
            projectId: "playmobil-2d74d",
            storageBucket: "playmobil-2d74d.firebasestorage.app",
            messagingSenderId: "85202851148",
            appId: "1:85202851148:web:bf8eba63238c06c7b4ebe9",
            measurementId: "G-MX2B76PCD6"
        };

        // Inicializar Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();
        
        // ============================
        // CONFIGURACI√ìN Y CONSTANTES
        // ============================
        const TILE_TYPES = {
            EMPTY: 'empty',
            WALL: 'wall',
            ZOMBIE: 'zombie',
            ZOMBIE_RAMBO: 'zombierambo',
            ROCK: 'rock',
            BOX: 'box',
            GRASS: 'grass',
            WATER: 'water',
            RIFLE: 'rifle',
            SHOTGUN: 'shotgun',
            KEY: 'key',
            PORTAL: 'portal',
            START: 'start',
            EXIT: 'exit',
            DOOR: 'door',
            COIN: 'coin',
            BOMB: 'bomb',
            SWORD: 'sword',
            CACTUS: 'cactus',
            BULLET: 'bullet',
            AMMO: 'ammo',
            PALANCA: 'palanca',
            VACUNA: 'vacuna'
        };

        const TILE_IMAGES = {
            [TILE_TYPES.WALL]: 'ladrillo.png',
            [TILE_TYPES.ROCK]: 'roca.png',
            [TILE_TYPES.GRASS]: 'pastizal.png',
            [TILE_TYPES.WATER]: 'agua.png',
            [TILE_TYPES.BOX]: 'caja.png',
            [TILE_TYPES.RIFLE]: 'rifle.png',
            [TILE_TYPES.SHOTGUN]: 'shotgun.png',
            [TILE_TYPES.KEY]: 'llave.png',
            [TILE_TYPES.PORTAL]: 'portal.png',
            [TILE_TYPES.START]: 'entradaocupada.png',
            [TILE_TYPES.EXIT]: 'exit.png',
            [TILE_TYPES.DOOR]: 'puerta.png',
            [TILE_TYPES.COIN]: 'moneda.png',
            [TILE_TYPES.BOMB]: 'bomba.png',
            [TILE_TYPES.SWORD]: 'espada.png',
            [TILE_TYPES.ZOMBIE]: 'zombie.png',
            [TILE_TYPES.ZOMBIE_RAMBO]: 'zombierambo.png',
            [TILE_TYPES.CACTUS]: 'cactus.png',
            [TILE_TYPES.BULLET]: 'balas.png',
            [TILE_TYPES.AMMO]: 'municiones.png',
            [TILE_TYPES.PALANCA]: 'palanca.png',
            [TILE_TYPES.VACUNA]: 'vacuna.png'
        };

        // PERSONAJES CON ESPECIFICACIONES
        const CHARACTERS = [
            { 
                id: 'civil', 
                name: 'Civil', 
                image: 'civil.png',
                price: 0,
                premium: false,
                health: 100, 
                speed: 0.8, // M√°s lento que antes
                damage: 10,
                description: 'Ciudadano com√∫n con instinto de supervivencia.',
                special: 'Puede pasar por pastizales'
            },
            { 
                id: 'pikachu', 
                name: 'Pikachu', 
                image: 'pikachu.png',
                price: 150,
                premium: true,
                health: 120, 
                speed: 1.0,
                damage: 30,
                description: '¬°Pika pika! Pok√©mon el√©ctrico con ataques r√°pidos.',
                special: 'Ataques el√©ctricos paralizantes'
            },
            { 
                id: 'batman', 
                name: 'Batman', 
                image: 'batman.png',
                price: 150,
                premium: true,
                health: 200, 
                speed: 0.9,
                damage: 40,
                description: 'El caballero oscuro, maestro del combate y sigilo.',
                special: 'Inmune a cactus'
            },
            { 
                id: 'superman', 
                name: 'Superman', 
                image: 'superman.png',
                price: 200,
                premium: true,
                health: 300, 
                speed: 1.1,
                damage: 60,
                description: 'El hombre de acero, invulnerable y superpoderoso.',
                special: 'Puede volar sobre agua'
            },
            { 
                id: 'goku', 
                name: 'Goku', 
                image: 'goku.png',
                price: 300,
                premium: true,
                health: 400, 
                speed: 1.2,
                damage: 80,
                description: 'El guerrero Saiyan. Kamehameha destructivo.',
                special: 'Ataque en √°rea grande'
            },
            { 
                id: 'ironman', 
                name: 'Ironman', 
                image: 'ironman.png',
                price: 350,
                premium: true,
                health: 220, 
                speed: 1.3,
                damage: 65,
                description: 'Tony Stark con armadura tecnol√≥gica.',
                special: 'Puede volar sobre obst√°culos'
            },
            { 
                id: 'rambo', 
                name: 'Rambo', 
                image: 'rambo.png',
                price: 320,
                premium: true,
                health: 280, 
                speed: 1.0,
                damage: 75,
                description: 'Soldado de √©lite. Munici√≥n infinita al comenzar.',
                special: 'Munici√≥n infinita inicial'
            },
            { 
                id: 'spiderman', 
                name: 'Spiderman', 
                image: 'spiderman.png',
                price: 290,
                premium: true,
                health: 210, 
                speed: 1.1,
                damage: 55,
                description: 'El trepamuros. Se mueve por las paredes.',
                special: 'Puede trepar paredes'
            },
            { 
                id: 'terminator', 
                name: 'Terminator', 
                image: 'terminator.png',
                price: 400,
                premium: true,
                health: 350, 
                speed: 0.9,
                damage: 85,
                description: 'M√°quina de guerra del futuro.',
                special: 'Resistencia al da√±o'
            }
        ];

        // ============================
        // VARIABLES GLOBALES DEL JUEGO
        // ============================
        let currentScreen = 'start-screen';
        let selectedCharacter = null;
        let currentLevelIndex = 0;
        let currentLevel = null;
        
        // Configuraci√≥n de movimiento
        const PLAYER_MOVE_DELAY = 700; // 0.7 segundos entre movimientos
        const ZOMBIE_MOVE_DELAY = 4000; // Zombis m√°s lentos
        const ZOMBIE_SPEED = 0.6; // Zombis m√°s lentos que el jugador
        
        let lastMoveTime = 0;
        let canMove = true;
        
        // Estado del juego principal
        let gameState = {
            grid: [],
            width: 10,
            height: 10,
            player: { 
                x: 0, 
                y: 0, 
                image: '', 
                health: 100, 
                maxHealth: 100, 
                playerId: 1,
                color: 'var(--player1)',
                name: 'Jugador 1'
            },
            otherPlayers: [],
            zombies: [],
            zombieRambos: [],
            portals: [],
            lives: 20,
            time: 120,
            ammo: 0,
            keys: 0,
            coins: 0,
            bombs: 0,
            shots: 0,
            playing: false,
            paused: false,
            levelName: 'Nivel 1',
            character: null,
            inventory: {
                rifles: 0,
                shotguns: 0,
                swords: 0,
                keys: 0,
                coins: 0,
                bombs: 0,
                bullets: 0,
                ammo: 0
            },
            weaponType: null,
            maxShots: 0,
            activeBombs: [],
            exitOpen: false,
            exitOpenTimer: 0,
            joystickActive: false,
            joystickDirection: { x: 0, y: 0 },
            joystickVelocity: { x: 0, y: 0 },
            zoomLevel: 1.0,
            cameraX: 0,
            cameraY: 0,
            cellSize: 50,
            isMultiplayer: false,
            roomId: null,
            multiplayerPlayers: {}
        };

        // Estado del editor
        let editorState = {
            tool: TILE_TYPES.WALL,
            grid: [],
            width: 10,
            height: 10,
            name: 'Mi Nivel Personalizado',
            timeLimit: 120,
            levelNumber: 1,
            levelType: 'custom',
            editingExisting: false,
            editingLevelIndex: -1
        };

        // Estad√≠sticas y datos guardados
        let savedLevels = [];
        let gameStats = {
            highscoreCoins: 0,
            totalLevels: 0,
            totalZombies: 0,
            currentLevel: 1,
            playerCoins: 0,
            unlockedCharacters: ['civil'],
            playerName: '',
            hasNickname: false,
            playerId: null
        };

        // Variables para carrusel
        let currentCarouselIndex = 0;
        let carouselItems = [];

        // Variables para joystick
        let joystickIsDragging = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let joystickMoveX = 0;
        let joystickMoveY = 0;
        const joystickMaxRadius = 70;

        // Detectar dispositivo t√°ctil
        let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let isFullscreen = false;

        // Highscores y multijugador
        let globalHighscores = [];
        let multiplayerRooms = [];
        let currentRoom = null;
        let roomListener = null;
        let gameListener = null;

        // ============================
        // INICIALIZACI√ìN
        // ============================
        document.addEventListener('DOMContentLoaded', async () => {
            showLoading('Inicializando juego...');
            
            // Cargar estad√≠sticas
            await loadStats();
            
            // Cargar niveles guardados
            const saved = localStorage.getItem('sandboxLevels');
            if (saved) {
                savedLevels = JSON.parse(saved);
            }
            
            // Crear nivel por defecto si no hay niveles
            if (savedLevels.length === 0) {
                createDefaultLevel();
            }

            // Inicializar componentes
            initializeEditor();
            initializeCharacterCarousel();
            
            // Configurar controles
            document.addEventListener('keydown', handleKeyPress);
            setupTouchControls();
            setupJoystick();
            
            // Cargar highscores
            await loadGlobalHighscores();
            
            // Configurar pantalla completa
            setupFullscreen();
            
            // Actualizar displays
            updateCoinsDisplay();
            
            // Verificar nickname
            setTimeout(() => {
                hideLoading();
                if (!gameStats.hasNickname) {
                    showNicknameModal();
                }
            }, 1500);
        });

        // ============================
        // SISTEMA DE LOADING
        // ============================
        function showLoading(text) {
            const overlay = document.getElementById('loading-overlay');
            const textEl = document.getElementById('loading-text');
            if (overlay && textEl) {
                textEl.textContent = text;
                overlay.classList.add('active');
            }
        }

        function hideLoading() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        // ============================
        // NOTIFICACIONES
        // ============================
        function showNotification(text, type = 'info') {
            const notification = document.getElementById('notification');
            const textEl = document.getElementById('notification-text');
            
            if (notification && textEl) {
                textEl.textContent = text;
                notification.className = `notification ${type}`;
                notification.classList.add('active');
                
                setTimeout(() => {
                    notification.classList.remove('active');
                }, 3000);
            }
        }

        // ============================
        // SISTEMA DE NICKNAME
        // ============================
        function showNicknameModal() {
            const modal = document.getElementById('nickname-modal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        function saveNickname() {
            const input = document.getElementById('nickname-input');
            if (!input) return;
            
            const nickname = input.value.trim();
            if (nickname === '') {
                showNotification('Por favor ingresa un nickname', 'error');
                return;
            }
            
            if (nickname.length < 3) {
                showNotification('El nickname debe tener al menos 3 caracteres', 'error');
                return;
            }
            
            if (nickname.length > 20) {
                showNotification('El nickname no puede tener m√°s de 20 caracteres', 'error');
                return;
            }
            
            // Generar ID √∫nico para el jugador
            gameStats.playerId = generatePlayerId();
            gameStats.playerName = nickname;
            gameStats.hasNickname = true;
            saveStats();
            
            const modal = document.getElementById('nickname-modal');
            if (modal) {
                modal.classList.remove('active');
            }
            
            showNotification(`¬°Bienvenido ${nickname}!`, 'success');
        }

        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ============================
        // MANEJO DE PANTALLAS
        // ============================
        function showScreen(screenName) {
            // Ocultar todas las pantallas
            const screens = ['start-screen', 'main-menu', 'character-select', 'editor-screen', 'game-screen', 'multiplayer-screen'];
            screens.forEach(screen => {
                const element = document.getElementById(screen);
                if (element) {
                    element.classList.remove('screen-active');
                    element.style.display = 'none';
                }
            });

            // Ocultar modales
            hideMessage();
            hideRoomModal();
            const inventoryModal = document.getElementById('inventory-modal');
            if (inventoryModal) inventoryModal.classList.remove('active');
            
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) bombSelector.classList.remove('active');
            
            const pauseOverlay = document.getElementById('pause-overlay');
            if (pauseOverlay) pauseOverlay.style.display = 'none';

            currentScreen = screenName;

            const targetScreen = document.getElementById(screenName);
            if (targetScreen) {
                targetScreen.style.display = screenName === 'start-screen' ? 'flex' : 'block';
                if (screenName !== 'start-screen') {
                    targetScreen.classList.add('screen-active');
                }
            }

            switch(screenName) {
                case 'main-menu':
                    updateStatsDisplay();
                    updateCoinsDisplay();
                    if (globalHighscores.length > 0) {
                        updateHighscoreTable();
                    }
                    initializeCharacterCarousel();
                    loadMultiplayerRooms();
                    break;
                case 'editor-screen':
                    loadEditor();
                    break;
                case 'game-screen':
                    startGame();
                    break;
                case 'multiplayer-screen':
                    loadMultiplayerRooms();
                    break;
            }
        }

        function startGameFromHome() {
            document.getElementById('start-screen').style.display = 'none';
            showScreen('main-menu');
        }

        // ============================
        // SISTEMA DE JOYSTICK MEJORADO
        // ============================
        function setupJoystick() {
            const joystickContainer = document.getElementById('joystick-container');
            const joystickKnob = document.getElementById('joystick-knob');
            const touchOverlay = document.getElementById('touch-controls-overlay');
            
            if (!joystickContainer || !joystickKnob) return;

            // Mostrar joystick en dispositivos t√°ctiles
            if (isTouchDevice && joystickContainer) {
                joystickContainer.style.display = 'flex';
            }

            function handleJoystickStart(e) {
                e.preventDefault();
                joystickIsDragging = true;
                
                const rect = joystickContainer.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;
                
                updateJoystick(e);
                
                if (touchOverlay) {
                    touchOverlay.classList.add('active');
                    touchOverlay.style.display = 'block';
                }
                
                // Efecto visual
                joystickKnob.style.animation = 'joystickPulse 1s infinite';
            }

            function handleJoystickMove(e) {
                if (!joystickIsDragging) return;
                e.preventDefault();
                updateJoystick(e);
            }

            function handleJoystickEnd() {
                joystickIsDragging = false;
                joystickKnob.style.transform = 'translate(0, 0)';
                joystickKnob.style.animation = '';
                gameState.joystickDirection = { x: 0, y: 0 };
                gameState.joystickVelocity = { x: 0, y: 0 };
                
                if (touchOverlay) {
                    touchOverlay.classList.remove('active');
                    touchOverlay.style.display = 'none';
                }
            }

            function updateJoystick(e) {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                let dx = clientX - joystickStartX;
                let dy = clientY - joystickStartY;
                let distance = Math.sqrt(dx * dx + dy * dy);

                // Limitar al radio m√°ximo
                if (distance > joystickMaxRadius) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * joystickMaxRadius;
                    dy = Math.sin(angle) * joystickMaxRadius;
                    distance = joystickMaxRadius;
                }

                // Mover el knob
                joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;
                
                // Calcular direcci√≥n normalizada
                gameState.joystickDirection = {
                    x: dx / joystickMaxRadius,
                    y: dy / joystickMaxRadius
                };
                
                // Mover al jugador si hay suficiente direcci√≥n
                if (Math.abs(gameState.joystickDirection.x) > 0.3 || Math.abs(gameState.joystickDirection.y) > 0.3) {
                    moveWithJoystick();
                }
            }

            // Eventos t√°ctiles
            joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
            window.addEventListener('touchmove', handleJoystickMove, { passive: false });
            window.addEventListener('touchend', handleJoystickEnd, { passive: true });
            window.addEventListener('touchcancel', handleJoystickEnd, { passive: true });

            // Eventos de rat√≥n
            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            window.addEventListener('mousemove', handleJoystickMove);
            window.addEventListener('mouseup', handleJoystickEnd);
        }

        function moveWithJoystick() {
            if (!gameState.playing || gameState.paused || !canMove) return;
            
            const currentTime = Date.now();
            if (currentTime - lastMoveTime < PLAYER_MOVE_DELAY) {
                return;
            }
            
            let moveX = 0;
            let moveY = 0;
            
            // Determinar direcci√≥n principal
            if (Math.abs(gameState.joystickDirection.x) > Math.abs(gameState.joystickDirection.y)) {
                moveX = gameState.joystickDirection.x > 0.3 ? 1 : (gameState.joystickDirection.x < -0.3 ? -1 : 0);
            } else {
                moveY = gameState.joystickDirection.y > 0.3 ? 1 : (gameState.joystickDirection.y < -0.3 ? -1 : 0);
            }
            
            if (moveX !== 0 || moveY !== 0) {
                movePlayer(moveX, moveY);
                lastMoveTime = currentTime;
                canMove = false;
                
                // Permitir pr√≥ximo movimiento despu√©s del delay
                setTimeout(() => {
                    canMove = true;
                }, PLAYER_MOVE_DELAY);
            }
        }

        // ============================
        // CARRUSEL DE PERSONAJES
        // ============================
        function initializeCharacterCarousel() {
            const carouselContainer = document.getElementById('character-carousel');
            const indicatorsContainer = document.getElementById('carousel-indicators');
            const carouselParent = document.getElementById('carousel-container');
            
            if (!carouselContainer || !indicatorsContainer) return;
            
            carouselContainer.innerHTML = '';
            indicatorsContainer.innerHTML = '';
            carouselItems = [];
            
            CHARACTERS.forEach((character, index) => {
                const isUnlocked = gameStats.unlockedCharacters.includes(character.id);
                const canAfford = gameStats.playerCoins >= character.price;
                
                const carouselItem = document.createElement('div');
                carouselItem.className = `character-carousel-item ${index === currentCarouselIndex ? 'active' : ''}`;
                carouselItem.dataset.index = index;
                carouselItem.dataset.characterId = character.id;
                
                const isAvailable = isUnlocked || (!character.premium && canAfford);
                
                if (index === 0 && isUnlocked && !selectedCharacter) {
                    selectedCharacter = character;
                }
                
                const isSelected = selectedCharacter && selectedCharacter.id === character.id && isAvailable;
                
                carouselItem.innerHTML = `
                    <div class="character-carousel-preview" style="background-image: url('${character.image}')"></div>
                    <div class="character-carousel-info">
                        <h3>${character.name} ${character.premium ? 'üëë' : ''}</h3>
                        <p class="character-carousel-description">${character.description}</p>
                        
                        <div class="character-carousel-stats">
                            <div class="carousel-stat">
                                <div class="carousel-stat-value">${character.health}</div>
                                <div class="carousel-stat-label">Salud</div>
                            </div>
                            <div class="carousel-stat">
                                <div class="carousel-stat-value">${character.speed.toFixed(1)}</div>
                                <div class="carousel-stat-label">Velocidad</div>
                            </div>
                            <div class="carousel-stat">
                                <div class="carousel-stat-value">${character.damage}</div>
                                <div class="carousel-stat-label">Da√±o</div>
                            </div>
                        </div>
                        
                        <p style="color: var(--accent); font-size: 0.9rem; margin: 0.5rem 0;">
                            <i class="fas fa-star"></i> ${character.special}
                        </p>
                        
                        ${character.price > 0 ? `
                            <div class="coin-price" style="justify-content: center; margin-bottom: 1rem;">
                                <img src="moneda.png" alt="Monedas" onerror="this.parentElement.innerHTML='üí∞ <span>${character.price} monedas</span>'">
                                <span>${character.price} monedas</span>
                            </div>
                        ` : ''}
                        
                        <div class="carousel-buttons">
                            ${isUnlocked ? `
                                <button class="btn ${isSelected ? 'btn-primary' : 'btn-secondary'}" 
                                        onclick="selectCharacterFromCarousel(${index})"
                                        style="min-width: 160px;">
                                    ${isSelected ? '<i class="fas fa-check"></i> Seleccionado' : 'Seleccionar'}
                                </button>
                            ` : `
                                <button class="btn ${canAfford ? 'btn-primary' : 'btn-secondary'}" 
                                        onclick="buyCharacterFromCarousel(${index})"
                                        style="min-width: 160px;"
                                        ${!canAfford ? 'disabled' : ''}>
                                    <i class="fas fa-shopping-cart"></i> 
                                    ${canAfford ? `Comprar (${character.price})` : `Faltan ${character.price - gameStats.playerCoins}`}
                                </button>
                            `}
                        </div>
                    </div>
                `;
                
                carouselContainer.appendChild(carouselItem);
                carouselItems.push({
                    element: carouselItem,
                    character: character,
                    isUnlocked: isUnlocked,
                    isAvailable: isAvailable
                });
                
                const indicator = document.createElement('div');
                indicator.className = `carousel-indicator ${index === currentCarouselIndex ? 'active' : ''}`;
                indicator.dataset.index = index;
                indicator.onclick = () => goToCharacter(index);
                indicatorsContainer.appendChild(indicator);
            });
            
            updateCarouselPosition();
            setupCarouselTouchEvents();
        }

        function setupCarouselTouchEvents() {
            const carouselParent = document.getElementById('carousel-container');
            if (!carouselParent) return;
            
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            
            carouselParent.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                currentX = startX;
                isDragging = true;
            }, { passive: false });
            
            carouselParent.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                
                currentX = e.touches[0].clientX;
                const diff = currentX - startX;
                const threshold = window.innerWidth * 0.1;
                
                if (Math.abs(diff) > threshold) {
                    if (diff > 0) {
                        previousCharacter();
                        isDragging = false;
                    } else {
                        nextCharacter();
                        isDragging = false;
                    }
                }
            }, { passive: false });
            
            carouselParent.addEventListener('touchend', () => {
                isDragging = false;
                updateCarouselPosition();
            });
            
            // Eventos de rat√≥n
            carouselParent.addEventListener('mousedown', (e) => {
                startX = e.clientX;
                currentX = startX;
                isDragging = true;
            });
            
            carouselParent.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                currentX = e.clientX;
                const diff = currentX - startX;
                const threshold = 50;
                
                if (Math.abs(diff) > threshold) {
                    if (diff > 0) {
                        previousCharacter();
                        isDragging = false;
                    } else {
                        nextCharacter();
                        isDragging = false;
                    }
                }
            });
            
            carouselParent.addEventListener('mouseup', () => {
                isDragging = false;
                updateCarouselPosition();
            });
            
            carouselParent.addEventListener('mouseleave', () => {
                isDragging = false;
                updateCarouselPosition();
            });
        }

        function updateCarouselPosition() {
            const carousel = document.getElementById('character-carousel');
            if (!carousel) return;
            
            carousel.style.transform = `translateX(-${currentCarouselIndex * 100}%)`;
            
            carouselItems.forEach((item, index) => {
                if (item.element) {
                    if (index === currentCarouselIndex) {
                        item.element.classList.add('active');
                    } else {
                        item.element.classList.remove('active');
                    }
                }
            });
            
            const indicators = document.querySelectorAll('.carousel-indicator');
            indicators.forEach((indicator, index) => {
                if (index === currentCarouselIndex) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                }
            });
        }

        function previousCharacter() {
            if (currentCarouselIndex > 0) {
                currentCarouselIndex--;
                updateCarouselPosition();
            }
        }

        function nextCharacter() {
            if (currentCarouselIndex < CHARACTERS.length - 1) {
                currentCarouselIndex++;
                updateCarouselPosition();
            }
        }

        function goToCharacter(index) {
            if (index >= 0 && index < CHARACTERS.length) {
                currentCarouselIndex = index;
                updateCarouselPosition();
            }
        }

        function selectCharacterFromCarousel(index) {
            if (index < 0 || index >= carouselItems.length) return;
            
            const item = carouselItems[index];
            if (!item.isAvailable) {
                showNotification('Personaje no disponible', 'error');
                return;
            }
            
            carouselItems.forEach(item => {
                const button = item.element.querySelector('button');
                if (button) {
                    button.className = button.className.replace('btn-primary', 'btn-secondary');
                    button.innerHTML = button.innerHTML.replace('<i class="fas fa-check"></i> Seleccionado', 'Seleccionar');
                }
            });
            
            selectedCharacter = item.character;
            
            const button = item.element.querySelector('button');
            if (button) {
                button.className = button.className.replace('btn-secondary', 'btn-primary');
                button.innerHTML = '<i class="fas fa-check"></i> Seleccionado';
            }
            
            showNotification(`${selectedCharacter.name} seleccionado`, 'success');
        }

        function buyCharacterFromCarousel(index) {
            if (index < 0 || index >= carouselItems.length) return;
            
            const item = carouselItems[index];
            if (!item.character.premium) return;
            
            if (gameStats.playerCoins >= item.character.price) {
                gameStats.playerCoins -= item.character.price;
                gameStats.unlockedCharacters.push(item.character.id);
                saveStats();
                
                showNotification(`¬°Has comprado a ${item.character.name}!`, 'success');
                
                initializeCharacterCarousel();
                selectCharacterFromCarousel(index);
            } else {
                showNotification(`Necesitas ${item.character.price - gameStats.playerCoins} monedas m√°s`, 'error');
            }
        }

        // ============================
        // CONTROLES T√ÅCTILES
        // ============================
        function setupTouchControls() {
            const touchShootBtn = document.getElementById('touch-shoot-btn');
            
            if (isTouchDevice) {
                if (touchShootBtn) {
                    touchShootBtn.classList.add('active');
                }
            }
            
            if (touchShootBtn) {
                touchShootBtn.addEventListener('touchstart', handleShootStart, { passive: false });
                touchShootBtn.addEventListener('touchend', handleShootEnd, { passive: true });
                touchShootBtn.addEventListener('mousedown', handleShootStart);
                touchShootBtn.addEventListener('mouseup', handleShootEnd);
            }
        }

        let shootInterval = null;
        let shootDelay = 500;
        
        function handleShootStart(e) {
            e.preventDefault();
            if (!gameState.playing || gameState.paused) return;
            
            if (gameState.weaponType === 'rifle') {
                shootDelay = 500;
            } else if (gameState.weaponType === 'shotgun') {
                shootDelay = 1000;
            } else {
                shootDelay = 300;
            }
            
            if (!shootInterval) {
                shootInterval = setInterval(() => {
                    if (gameState.playing && !gameState.paused) {
                        attack();
                    }
                }, shootDelay);
                
                attack();
            }
            
            const btn = document.getElementById('touch-shoot-btn');
            if (btn) {
                btn.style.transform = 'scale(0.9)';
                btn.style.background = 'radial-gradient(circle at 30% 30%, #dc2626, #450a0a)';
            }
        }
        
        function handleShootEnd(e) {
            e.preventDefault();
            if (shootInterval) {
                clearInterval(shootInterval);
                shootInterval = null;
            }
            
            const btn = document.getElementById('touch-shoot-btn');
            if (btn) {
                btn.style.transform = '';
                btn.style.background = '';
            }
        }

        // ============================
        // SISTEMA DE ESTAD√çSTICAS
        // ============================
        async function loadStats() {
            const savedStats = localStorage.getItem('sandboxStats');
            if (savedStats) {
                gameStats = JSON.parse(savedStats);
            }
            updateStatsDisplay();
            updateCoinsDisplay();
        }

        function saveStats() {
            localStorage.setItem('sandboxStats', JSON.stringify(gameStats));
            updateStatsDisplay();
            updateCoinsDisplay();
        }

        function updateStatsDisplay() {
            document.getElementById('highscore-coins').textContent = gameStats.highscoreCoins;
            document.getElementById('total-levels').textContent = gameStats.totalLevels;
            document.getElementById('total-zombies').textContent = gameStats.totalZombies;
        }

        function updateCoinsDisplay() {
            const coinsDisplay = document.getElementById('total-coins-display');
            if (coinsDisplay) {
                coinsDisplay.textContent = gameStats.playerCoins;
            }
        }

        // ============================
        // HIGHSCORE CON FIREBASE
        // ============================
        async function loadGlobalHighscores() {
            try {
                const snapshot = await db.collection('highscores')
                    .orderBy('score', 'desc')
                    .limit(20)
                    .get();
                
                globalHighscores = [];
                snapshot.forEach(doc => {
                    globalHighscores.push({ id: doc.id, ...doc.data() });
                });
                
                updateHighscoreTable();
            } catch (error) {
                console.error('Error cargando highscores:', error);
            }
        }

        function updateHighscoreTable() {
            const tableBody = document.getElementById('highscore-body');
            const loading = document.getElementById('highscore-loading');
            
            if (!tableBody || !loading) return;
            
            if (globalHighscores.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="6" class="text-center" style="color: #94a3b8;">
                            No hay puntajes registrados todav√≠a
                        </td>
                    </tr>
                `;
                loading.style.display = 'none';
                return;
            }
            
            tableBody.innerHTML = '';
            
            globalHighscores.forEach((score, index) => {
                const date = score.date ? new Date(score.date.seconds * 1000).toLocaleDateString() : 'Hoy';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="highscore-rank">
                        ${index + 1}
                        ${index < 3 ? getMedalEmoji(index) : ''}
                    </td>
                    <td class="highscore-name">${score.playerName}</td>
                    <td>${score.character}</td>
                    <td>${score.level}</td>
                    <td class="highscore-score">${score.score.toLocaleString()}</td>
                    <td style="color: #94a3b8; font-size: 0.9rem;">${date}</td>
                `;
                
                if (score.playerName === gameStats.playerName) {
                    row.style.backgroundColor = 'rgba(251, 191, 36, 0.1)';
                    row.style.borderLeft = '3px solid var(--accent)';
                }
                
                tableBody.appendChild(row);
            });
            
            loading.style.display = 'none';
        }

        function getMedalEmoji(rank) {
            switch(rank) {
                case 0: return 'ü•á';
                case 1: return 'ü•à';
                case 2: return 'ü•â';
                default: return '';
            }
        }

        async function submitHighscore(score, level, character) {
            if (!gameStats.playerName || gameStats.playerName.trim() === '') {
                return;
            }
            
            try {
                await db.collection('highscores').add({
                    playerName: gameStats.playerName,
                    character: character,
                    level: level,
                    score: score,
                    date: firebase.firestore.FieldValue.serverTimestamp(),
                    coins: gameState.coins
                });
                
                loadGlobalHighscores();
            } catch (error) {
                console.error('Error enviando highscore:', error);
            }
        }

        // ============================
        // BOT√ìN JUGAR PRINCIPAL
        // ============================
        function startGameFromMenu() {
            if (!selectedCharacter) {
                showNotification('Debes seleccionar un personaje primero', 'error');
                return;
            }
            
            if (selectedCharacter.premium && !gameStats.unlockedCharacters.includes(selectedCharacter.id)) {
                showNotification(`¬°${selectedCharacter.name} est√° bloqueado! Necesitas ${selectedCharacter.price} monedas.`, 'error');
                return;
            }
            
            if (savedLevels.length === 0) {
                showNotification('No hay niveles creados. Ve al Modo Cerebro para crear tu primer nivel.', 'error');
                showScreen('editor-screen');
                return;
            }
            
            currentLevelIndex = 0;
            currentLevel = savedLevels[currentLevelIndex];
            
            const savedProgress = localStorage.getItem('sandboxProgress');
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                if (progress.currentLevel > currentLevelIndex + 1) {
                    currentLevelIndex = progress.currentLevel - 1;
                    if (currentLevelIndex >= savedLevels.length) {
                        currentLevelIndex = 0;
                    }
                    currentLevel = savedLevels[currentLevelIndex];
                }
            }
            
            showScreen('game-screen');
        }

        // ============================
        // EDITOR DE NIVELES
        // ============================
        function initializeEditor() {
            const toolsContainer = document.getElementById('editor-tools');
            if (!toolsContainer) return;
            
            toolsContainer.innerHTML = '';

            const editorTools = [
                TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.BOX, TILE_TYPES.GRASS,
                TILE_TYPES.WATER, TILE_TYPES.RIFLE, TILE_TYPES.SHOTGUN, TILE_TYPES.SWORD,
                TILE_TYPES.KEY, TILE_TYPES.PORTAL, TILE_TYPES.START, TILE_TYPES.EXIT,
                TILE_TYPES.DOOR, TILE_TYPES.COIN, TILE_TYPES.BOMB, TILE_TYPES.CACTUS,
                TILE_TYPES.BULLET, TILE_TYPES.AMMO, TILE_TYPES.ZOMBIE, TILE_TYPES.ZOMBIE_RAMBO,
                TILE_TYPES.PALANCA, TILE_TYPES.VACUNA
            ];

            editorTools.forEach(type => {
                const tool = document.createElement('div');
                tool.className = `tool-btn ${editorState.tool === type ? 'active' : ''}`;
                
                const imageName = TILE_IMAGES[type];
                const displayName = getTileDisplayName(type);
                
                tool.innerHTML = `
                    <div class="tool-preview" style="background-image: url('${imageName || ''}')"></div>
                    <span>${displayName}</span>
                `;
                
                tool.onclick = () => {
                    editorState.tool = type;
                    document.querySelectorAll('.tool-btn').forEach(t => t.classList.remove('active'));
                    tool.classList.add('active');
                };
                
                toolsContainer.appendChild(tool);
            });
        }

        function getTileDisplayName(type) {
            const names = {
                [TILE_TYPES.WALL]: 'Ladrillo',
                [TILE_TYPES.ROCK]: 'Roca',
                [TILE_TYPES.BOX]: 'Caja',
                [TILE_TYPES.GRASS]: 'Pastizal',
                [TILE_TYPES.WATER]: 'Agua',
                [TILE_TYPES.RIFLE]: 'Rifle',
                [TILE_TYPES.SHOTGUN]: 'Shotgun',
                [TILE_TYPES.SWORD]: 'Espada',
                [TILE_TYPES.KEY]: 'Llave',
                [TILE_TYPES.PORTAL]: 'Portal',
                [TILE_TYPES.START]: 'Entrada',
                [TILE_TYPES.EXIT]: 'Salida',
                [TILE_TYPES.DOOR]: 'Puerta',
                [TILE_TYPES.COIN]: 'Moneda',
                [TILE_TYPES.BOMB]: 'Bomba',
                [TILE_TYPES.CACTUS]: 'Cactus',
                [TILE_TYPES.BULLET]: 'Balas',
                [TILE_TYPES.AMMO]: 'Munici√≥n',
                [TILE_TYPES.ZOMBIE]: 'Zombie',
                [TILE_TYPES.ZOMBIE_RAMBO]: 'Zombie Rambo',
                [TILE_TYPES.PALANCA]: 'Palanca',
                [TILE_TYPES.VACUNA]: 'Vacuna'
            };
            
            return names[type] || type;
        }

        function updateEditorSize() {
            const boardSize = document.getElementById('editor-board-size');
            if (!boardSize) return;
            
            const size = parseInt(boardSize.value);
            editorState.width = size;
            editorState.height = size;
            
            editorState.grid = Array(size * size).fill(TILE_TYPES.EMPTY);
            
            renderEditorGrid();
        }

        function loadEditor() {
            const boardSize = document.getElementById('editor-board-size');
            const editorTime = document.getElementById('editor-time');
            const levelNameInput = document.getElementById('editor-level-name-input');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (boardSize && editorTime && levelNameInput && levelNumberInput) {
                editorState.width = parseInt(boardSize.value);
                editorState.height = parseInt(boardSize.value);
                editorState.timeLimit = parseInt(editorTime.value);
                editorState.name = levelNameInput.value;
                editorState.levelNumber = parseInt(levelNumberInput.value);
            }
            
            if (editorState.grid.length !== editorState.width * editorState.height) {
                editorState.grid = Array(editorState.width * editorState.height).fill(TILE_TYPES.EMPTY);
            }
            
            renderEditorGrid();
        }

        function renderEditorGrid() {
            const board = document.getElementById('editor-board');
            if (!board) return;
            
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${editorState.width}, 40px)`;
            board.style.width = `${editorState.width * 40}px`;
            board.style.height = `${editorState.height * 40}px`;

            for (let y = 0; y < editorState.height; y++) {
                for (let x = 0; x < editorState.width; x++) {
                    const index = y * editorState.width + x;
                    const tileType = editorState.grid[index] || TILE_TYPES.EMPTY;
                    const image = TILE_IMAGES[tileType];

                    const cell = document.createElement('div');
                    cell.className = `editor-cell ${tileType === TILE_TYPES.EMPTY ? 'cell-empty' : ''}`;
                    
                    if (image && tileType !== TILE_TYPES.EMPTY) {
                        cell.style.backgroundImage = `url('${image}')`;
                        if (tileType === TILE_TYPES.COIN) {
                            cell.style.backgroundSize = 'cover';
                        }
                    }

                    cell.title = getTileDisplayName(tileType);

                    cell.onclick = () => {
                        if (editorState.tool === TILE_TYPES.START) {
                            for (let i = 0; i < editorState.grid.length; i++) {
                                if (editorState.grid[i] === TILE_TYPES.START) {
                                    editorState.grid[i] = TILE_TYPES.EMPTY;
                                }
                            }
                        }
                        if (editorState.tool === TILE_TYPES.EXIT || editorState.tool === TILE_TYPES.DOOR) {
                            for (let i = 0; i < editorState.grid.length; i++) {
                                if (editorState.grid[i] === TILE_TYPES.EXIT || editorState.grid[i] === TILE_TYPES.DOOR) {
                                    editorState.grid[i] = TILE_TYPES.EMPTY;
                                }
                            }
                        }

                        editorState.grid[index] = editorState.tool;
                        renderEditorGrid();
                    };

                    board.appendChild(cell);
                }
            }
        }

        function createNewLevel() {
            editorState = {
                tool: TILE_TYPES.WALL,
                grid: Array(100).fill(TILE_TYPES.EMPTY),
                width: 10,
                height: 10,
                name: 'Mi Nivel Personalizado',
                timeLimit: 120,
                levelNumber: savedLevels.length > 0 ? Math.max(...savedLevels.map(l => l.levelNumber)) + 1 : 1,
                levelType: 'custom',
                editingExisting: false,
                editingLevelIndex: -1
            };
            
            const boardSize = document.getElementById('editor-board-size');
            const editorTime = document.getElementById('editor-time');
            const levelNameInput = document.getElementById('editor-level-name-input');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (boardSize) boardSize.value = '10';
            if (editorTime) editorTime.value = '120';
            if (levelNameInput) levelNameInput.value = 'Mi Nivel Personalizado';
            if (levelNumberInput) levelNumberInput.value = editorState.levelNumber.toString();
            
            loadEditor();
        }

        function saveLevel() {
            const levelNameInput = document.getElementById('editor-level-name-input');
            const editorTime = document.getElementById('editor-time');
            const boardSize = document.getElementById('editor-board-size');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (!levelNameInput || !editorTime || !boardSize || !levelNumberInput) return;
            
            const name = levelNameInput.value || 'Mi Nivel Personalizado';
            const levelNumber = parseInt(levelNumberInput.value) || 1;
            
            editorState.name = name;
            editorState.timeLimit = parseInt(editorTime.value) || 120;
            editorState.width = parseInt(boardSize.value);
            editorState.height = parseInt(boardSize.value);
            editorState.levelNumber = levelNumber;
            editorState.levelType = 'custom';
            
            const hasStart = editorState.grid.some(tile => tile === TILE_TYPES.START);
            const hasExit = editorState.grid.some(tile => tile === TILE_TYPES.EXIT || tile === TILE_TYPES.DOOR);
            
            if (!hasStart) {
                showNotification('Debes colocar al menos una entrada (START) en el nivel', 'error');
                return;
            }
            
            if (!hasExit) {
                showNotification('Debes colocar al menos una salida (EXIT o DOOR) en el nivel', 'error');
                return;
            }
            
            const newLevel = {
                name: editorState.name,
                width: editorState.width,
                height: editorState.height,
                timeLimit: editorState.timeLimit,
                levelNumber: editorState.levelNumber,
                levelType: editorState.levelType,
                grid: [...editorState.grid]
            };

            const existingIndex = savedLevels.findIndex(level => 
                level.name === newLevel.name && level.levelNumber === newLevel.levelNumber
            );
            
            if (existingIndex !== -1 && !editorState.editingExisting) {
                showNotification('Ya existe un nivel con este nombre y n√∫mero', 'error');
                return;
            }

            if (editorState.editingExisting && editorState.editingLevelIndex >= 0) {
                savedLevels[editorState.editingLevelIndex] = newLevel;
                showNotification(`El nivel "${name}" ha sido actualizado`, 'success');
            } else {
                savedLevels.push(newLevel);
                showNotification(`El nivel "${name}" ha sido guardado`, 'success');
            }
            
            localStorage.setItem('sandboxLevels', JSON.stringify(savedLevels));
            
            editorState.editingExisting = false;
            editorState.editingLevelIndex = -1;
        }

        function playCurrentLevel() {
            if (editorState.grid.length === 0) {
                showNotification('Primero debes crear un nivel', 'error');
                return;
            }
            
            const hasStart = editorState.grid.some(tile => tile === TILE_TYPES.START);
            const hasExit = editorState.grid.some(tile => tile === TILE_TYPES.EXIT || tile === TILE_TYPES.DOOR);
            
            if (!hasStart) {
                showNotification('Debes colocar al menos una entrada (START) en el nivel', 'error');
                return;
            }
            
            if (!hasExit) {
                showNotification('Debes colocar al menos una salida (EXIT o DOOR) en el nivel', 'error');
                return;
            }
            
            const tempLevel = {
                name: editorState.name,
                width: editorState.width,
                height: editorState.height,
                timeLimit: editorState.timeLimit,
                levelNumber: editorState.levelNumber,
                levelType: editorState.levelType,
                grid: [...editorState.grid]
            };
            
            currentLevel = tempLevel;
            currentLevelIndex = -1;
            showScreen('game-screen');
        }

        // ============================
        // SISTEMA DE NIVELES GUARDADOS
        // ============================
        function loadLevelsModal() {
            const levelsModal = document.getElementById('levels-modal');
            const levelsList = document.getElementById('levels-list');
            
            if (!levelsModal || !levelsList) return;
            
            levelsList.innerHTML = '';
            
            savedLevels.sort((a, b) => a.levelNumber - b.levelNumber).forEach((level, index) => {
                const levelItem = document.createElement('div');
                levelItem.className = 'level-item';
                levelItem.style.cssText = `
                    background: rgba(30, 41, 59, 0.7);
                    border-radius: 10px;
                    padding: 1rem;
                    margin-bottom: 0.5rem;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                levelItem.innerHTML = `
                    <div class="level-info" style="flex: 1;">
                        <h3 style="color: var(--accent); margin-bottom: 0.5rem;">${level.name}</h3>
                        <p style="color: #94a3b8; font-size: 0.9rem;">
                            Nivel: ${level.levelNumber} | 
                            Tama√±o: ${level.width}x${level.height} | 
                            Tiempo: ${level.timeLimit}s
                        </p>
                    </div>
                    <div class="level-actions" style="display: flex; gap: 0.5rem;">
                        <button class="level-action-btn" onclick="playLevel(${index})" style="background: rgba(255, 255, 255, 0.1); border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 5px; cursor: pointer;">
                            <i class="fas fa-play"></i>
                        </button>
                        <button class="level-action-btn" onclick="editLevel(${index})" style="background: rgba(255, 255, 255, 0.1); border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 5px; cursor: pointer;">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="level-action-btn delete" onclick="deleteLevel(${index})" style="background: rgba(239, 68, 68, 0.2); border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 5px; cursor: pointer;">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                
                levelsList.appendChild(levelItem);
            });
            
            if (savedLevels.length === 0) {
                levelsList.innerHTML = '<p style="text-align: center; color: #94a3b8;">No hay niveles guardados</p>';
            }
            
            levelsModal.classList.add('active');
        }

        function filterLevels(type) {
            const filterBtns = document.querySelectorAll('.filter-btn');
            filterBtns.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const levelsList = document.getElementById('levels-list');
            if (!levelsList) return;
            
            levelsList.innerHTML = '';
            
            let filteredLevels = savedLevels;
            if (type === 'custom') {
                filteredLevels = savedLevels.filter(level => level.levelType === 'custom');
            }
            
            filteredLevels.sort((a, b) => a.levelNumber - b.levelNumber).forEach((level, index) => {
                const originalIndex = savedLevels.findIndex(l => 
                    l.name === level.name && l.levelNumber === level.levelNumber
                );
                
                const levelItem = document.createElement('div');
                levelItem.className = 'level-item';
                levelItem.style.cssText = `
                    background: rgba(30, 41, 59, 0.7);
                    border-radius: 10px;
                    padding: 1rem;
                    margin-bottom: 0.5rem;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                levelItem.innerHTML = `
                    <div class="level-info" style="flex: 1;">
                        <h3 style="color: var(--accent); margin-bottom: 0.5rem;">${level.name}</h3>
                        <p style="color: #94a3b8; font-size: 0.9rem;">
                            Nivel: ${level.levelNumber} | 
                            Tama√±o: ${level.width}x${level.height} | 
                            Tiempo: ${level.timeLimit}s
                        </p>
                    </div>
                    <div class="level-actions" style="display: flex; gap: 0.5rem;">
                        <button class="level-action-btn" onclick="playLevel(${originalIndex})" style="background: rgba(255, 255, 255, 0.1); border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 5px; cursor: pointer;">
                            <i class="fas fa-play"></i>
                        </button>
                        <button class="level-action-btn" onclick="editLevel(${originalIndex})" style="background: rgba(255, 255, 255, 0.1); border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 5px; cursor: pointer;">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="level-action-btn delete" onclick="deleteLevel(${originalIndex})" style="background: rgba(239, 68, 68, 0.2); border: none; color: white; padding: 0.25rem 0.5rem; border-radius: 5px; cursor: pointer;">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                
                levelsList.appendChild(levelItem);
            });
            
            if (filteredLevels.length === 0) {
                levelsList.innerHTML = '<p style="text-align: center; color: #94a3b8;">No hay niveles guardados</p>';
            }
        }

        function playLevel(index) {
            if (index < 0 || index >= savedLevels.length) return;
            
            currentLevelIndex = index;
            currentLevel = savedLevels[index];
            hideMessage();
            showScreen('game-screen');
        }

        function editLevel(index) {
            if (index < 0 || index >= savedLevels.length) return;
            
            const level = savedLevels[index];
            
            editorState = {
                tool: TILE_TYPES.WALL,
                grid: [...level.grid],
                width: level.width,
                height: level.height,
                name: level.name,
                timeLimit: level.timeLimit,
                levelNumber: level.levelNumber,
                levelType: level.levelType,
                editingExisting: true,
                editingLevelIndex: index
            };
            
            const boardSize = document.getElementById('editor-board-size');
            const editorTime = document.getElementById('editor-time');
            const levelNameInput = document.getElementById('editor-level-name-input');
            const levelNumberInput = document.getElementById('editor-level-number');
            
            if (boardSize) boardSize.value = level.width.toString();
            if (editorTime) editorTime.value = level.timeLimit.toString();
            if (levelNameInput) levelNameInput.value = level.name;
            if (levelNumberInput) levelNumberInput.value = level.levelNumber.toString();
            
            hideMessage();
            showScreen('editor-screen');
        }

        function deleteLevel(index) {
            if (index < 0 || index >= savedLevels.length) return;
            
            const levelName = savedLevels[index].name;
            if (confirm(`¬øEst√°s seguro de que quieres eliminar el nivel "${levelName}"?`)) {
                savedLevels.splice(index, 1);
                localStorage.setItem('sandboxLevels', JSON.stringify(savedLevels));
                loadLevelsModal();
                showNotification(`El nivel "${levelName}" ha sido eliminado`, 'success');
            }
        }

        // ============================
        // JUEGO PRINCIPAL - CON MOVIMIENTO M√ÅS LENTO
        // ============================
        function startGame() {
            if (!currentLevel) {
                if (savedLevels.length === 0) {
                    showNotification('No hay niveles creados. Ve al Modo Cerebro para crear tu primer nivel.', 'error');
                    showScreen('editor-screen');
                    return;
                }
                currentLevel = savedLevels[currentLevelIndex];
            }

            const characterHealth = selectedCharacter ? selectedCharacter.health : 100;
            
            // Resetear estado de movimiento
            lastMoveTime = 0;
            canMove = true;
            
            // Ajustar tama√±o de celda din√°micamente
            const container = document.getElementById('game-board-container');
            if (container) {
                const containerRect = container.getBoundingClientRect();
                const maxCellSize = Math.min(
                    containerRect.width / currentLevel.width,
                    containerRect.height / currentLevel.height
                );
                gameState.cellSize = Math.max(40, Math.min(80, maxCellSize));
            }
            
            gameState = {
                grid: [...currentLevel.grid],
                width: currentLevel.width,
                height: currentLevel.height,
                player: {
                    x: 0,
                    y: 0,
                    image: selectedCharacter.image,
                    health: characterHealth,
                    maxHealth: characterHealth,
                    playerId: 1,
                    color: 'var(--player1)',
                    name: gameStats.playerName || 'Jugador 1'
                },
                otherPlayers: [],
                zombies: [],
                zombieRambos: [],
                portals: [],
                boxes: [],
                lives: 20,
                time: currentLevel.timeLimit,
                ammo: 0,
                keys: 0,
                coins: 0,
                bombs: 0,
                shots: 0,
                playing: true,
                paused: false,
                levelName: currentLevel.name,
                character: selectedCharacter,
                inventory: {
                    rifles: 0,
                    shotguns: 0,
                    swords: 0,
                    keys: 0,
                    coins: 0,
                    bombs: 0,
                    bullets: 0,
                    ammo: 0
                },
                weaponType: null,
                maxShots: 0,
                activeBombs: [],
                exitOpen: false,
                exitOpenTimer: 0,
                joystickActive: false,
                joystickDirection: { x: 0, y: 0 },
                joystickVelocity: { x: 0, y: 0 },
                zoomLevel: 1.0,
                cameraX: 0,
                cameraY: 0,
                cellSize: gameState.cellSize,
                isMultiplayer: false,
                roomId: null,
                multiplayerPlayers: {}
            };

            // Encontrar posici√≥n inicial
            const startPos = findStartPosition();
            gameState.player.x = startPos.x;
            gameState.player.y = startPos.y;

            // Encontrar enemigos y objetos
            gameState.zombies = findZombies();
            gameState.zombieRambos = findZombieRambos();
            gameState.portals = findPortals();
            gameState.boxes = findBoxes();

            // Actualizar HUD
            updateHUD();
            updateHealthBar();
            renderGameGrid();

            // Actualizar displays
            const currentLevelEl = document.getElementById('current-level');
            const characterNameEl = document.getElementById('character-name');
            
            if (currentLevelEl) currentLevelEl.textContent = currentLevel.levelNumber || gameStats.currentLevel;
            if (characterNameEl) characterNameEl.textContent = selectedCharacter.name;

            // Mostrar controles t√°ctiles
            if (isTouchDevice) {
                const joystickContainer = document.getElementById('joystick-container');
                if (joystickContainer) {
                    joystickContainer.style.display = 'flex';
                }
            }

            // Limpiar timers anteriores
            if (gameState.timer) clearInterval(gameState.timer);
            if (gameState.zombieTimer) clearInterval(gameState.zombieTimer);
            if (gameState.zombieRamboTimer) clearInterval(gameState.zombieRamboTimer);
            if (gameState.bombTimer) clearInterval(gameState.bombTimer);
            if (gameState.exitTimer) clearInterval(gameState.exitTimer);

            // Iniciar timers
            gameState.timer = setInterval(gameLoop, 1000);
            gameState.zombieTimer = setInterval(moveZombies, ZOMBIE_MOVE_DELAY);
            gameState.zombieRamboTimer = setInterval(moveZombieRambos, ZOMBIE_MOVE_DELAY * 0.75);
            gameState.bombTimer = setInterval(updateBombs, 1000);
            gameState.exitTimer = setInterval(updateExitTimer, 1000);
        }

        function findStartPosition() {
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.START) {
                    return {
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width)
                    };
                }
            }
            return { x: 0, y: 0 };
        }

        function findZombies() {
            const zombies = [];
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.ZOMBIE) {
                    zombies.push({
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width),
                        id: zombies.length,
                        image: 'zombie.png',
                        lastMoveDirection: null,
                        speed: ZOMBIE_SPEED // Zombis m√°s lentos
                    });
                }
            }
            return zombies;
        }

        function findZombieRambos() {
            const zombieRambos = [];
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.ZOMBIE_RAMBO) {
                    zombieRambos.push({
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width),
                        id: zombieRambos.length,
                        image: 'zombierambo.png',
                        lastMoveDirection: null,
                        speed: ZOMBIE_SPEED * 0.8, // Zombie Rambos un poco m√°s r√°pidos
                        lastShotTime: 0,
                        shotCooldown: 6000
                    });
                }
            }
            return zombieRambos;
        }

        function findPortals() {
            const portals = [];
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.PORTAL) {
                    portals.push({
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width),
                        id: portals.length
                    });
                }
            }
            return portals;
        }

        function findBoxes() {
            const boxes = [];
            for (let i = 0; i < gameState.grid.length; i++) {
                if (gameState.grid[i] === TILE_TYPES.BOX) {
                    boxes.push({
                        x: i % gameState.width,
                        y: Math.floor(i / gameState.width),
                        index: i
                    });
                }
            }
            return boxes;
        }

        function renderGameGrid() {
            const board = document.getElementById('game-board');
            if (!board) return;
            
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${gameState.width}, ${gameState.cellSize}px)`;
            board.style.gridTemplateRows = `repeat(${gameState.height}, ${gameState.cellSize}px)`;
            board.style.width = `${gameState.width * gameState.cellSize}px`;
            board.style.height = `${gameState.height * gameState.cellSize}px`;

            for (let y = 0; y < gameState.height; y++) {
                for (let x = 0; x < gameState.width; x++) {
                    const index = y * gameState.width + x;
                    const tileType = gameState.grid[index];
                    const image = TILE_IMAGES[tileType];

                    const cell = document.createElement('div');
                    cell.className = `game-cell cell-${tileType}`;
                    
                    if (image && tileType !== TILE_TYPES.EMPTY && 
                        tileType !== TILE_TYPES.ZOMBIE && tileType !== TILE_TYPES.ZOMBIE_RAMBO) {
                        cell.style.backgroundImage = `url('${image}')`;
                        if (tileType === TILE_TYPES.COIN) {
                            cell.style.backgroundSize = 'cover';
                        }
                    }

                    // Verificar jugador principal
                    if (gameState.player.x === x && gameState.player.y === y) {
                        cell.classList.add('player-1-cell');
                        cell.style.backgroundImage = `url('${gameState.player.image}')`;
                        
                        const healthBarContainer = document.createElement('div');
                        healthBarContainer.className = 'health-bar-container';
                        const healthBar = document.createElement('div');
                        healthBar.className = 'health-bar';
                        healthBar.style.width = `${(gameState.player.health / gameState.player.maxHealth) * 100}%`;
                        healthBarContainer.appendChild(healthBar);
                        cell.appendChild(healthBarContainer);
                    }

                    // Verificar otros jugadores (multijugador)
                    gameState.otherPlayers.forEach((player, index) => {
                        if (player.x === x && player.y === y) {
                            cell.classList.add(`player-${index + 2}-cell`);
                            cell.style.backgroundImage = `url('${player.image}')`;
                            
                            const healthBarContainer = document.createElement('div');
                            healthBarContainer.className = 'health-bar-container';
                            const healthBar = document.createElement('div');
                            healthBar.className = 'health-bar';
                            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
                            healthBarContainer.appendChild(healthBar);
                            cell.appendChild(healthBarContainer);
                        }
                    });

                    // Verificar zombies
                    const zombieHere = gameState.zombies.find(z => z.x === x && z.y === y);
                    if (zombieHere) {
                        cell.classList.add('zombie-cell');
                        cell.style.backgroundImage = `url('${zombieHere.image}')`;
                    }

                    // Verificar zombie rambos
                    const zombieRamboHere = gameState.zombieRambos.find(z => z.x === x && z.y === y);
                    if (zombieRamboHere) {
                        cell.classList.add('zombie-cell');
                        cell.style.backgroundImage = `url('${zombieRamboHere.image}')`;
                    }

                    board.appendChild(cell);
                }
            }
        }

        function updateHUD() {
            const healthEl = document.getElementById('health');
            const healthBar = document.getElementById('health-bar');
            const timeEl = document.getElementById('time');
            const characterNameEl = document.getElementById('character-name');
            const keysEl = document.getElementById('keys');
            const coinsEl = document.getElementById('coins');
            const bombsEl = document.getElementById('bombs');
            const shotsEl = document.getElementById('shots');
            
            if (healthEl) healthEl.textContent = gameState.player.health;
            if (healthBar) {
                const healthPercentage = (gameState.player.health / gameState.player.maxHealth) * 100;
                healthBar.style.width = `${healthPercentage}%`;
            }
            if (timeEl) timeEl.textContent = gameState.time;
            if (characterNameEl) characterNameEl.textContent = selectedCharacter.name;
            if (keysEl) keysEl.textContent = gameState.keys;
            if (coinsEl) coinsEl.textContent = gameState.coins;
            if (bombsEl) bombsEl.textContent = gameState.bombs;
            if (shotsEl) shotsEl.textContent = `${gameState.shots}/${gameState.maxShots}`;
        }

        function updateHealthBar() {
            const healthBar = document.getElementById('health-bar');
            if (healthBar) {
                const healthPercentage = (gameState.player.health / gameState.player.maxHealth) * 100;
                healthBar.style.width = `${healthPercentage}%`;
                
                if (healthPercentage > 60) {
                    healthBar.style.background = 'linear-gradient(90deg, #10b981, #fbbf24)';
                } else if (healthPercentage > 30) {
                    healthBar.style.background = 'linear-gradient(90deg, #fbbf24, #f59e0b)';
                } else {
                    healthBar.style.background = 'linear-gradient(90deg, #f59e0b, #ef4444)';
                }
            }
        }

        // ============================
        // SISTEMA DE MOVIMIENTO M√ÅS LENTO
        // ============================
        function movePlayer(dx, dy) {
            if (!gameState.playing || gameState.paused) return;
            
            const currentTime = Date.now();
            if (currentTime - lastMoveTime < PLAYER_MOVE_DELAY) {
                return;
            }
            
            lastMoveTime = currentTime;
            
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;

            if (newX < 0 || newX >= gameState.width || newY < 0 || newY >= gameState.height) {
                return;
            }

            const newIndex = newY * gameState.width + newX;
            const tile = gameState.grid[newIndex];

            // Verificar colisiones
            if (tile === TILE_TYPES.CACTUS) {
                if (selectedCharacter.id !== 'batman') {
                    applyDamage(selectedCharacter ? selectedCharacter.damage : 10);
                }
                return;
            }

            if ([TILE_TYPES.WALL, TILE_TYPES.ROCK].includes(tile)) {
                return;
            }

            if (tile === TILE_TYPES.DOOR && gameState.keys === 0) {
                return;
            }

            // Manejar portal
            if (tile === TILE_TYPES.PORTAL && gameState.portals.length >= 2) {
                const currentPortal = gameState.portals.find(p => p.x === newX && p.y === newY);
                if (currentPortal) {
                    const otherPortal = gameState.portals.find(p => p.id !== currentPortal.id);
                    if (otherPortal) {
                        gameState.player.x = otherPortal.x;
                        gameState.player.y = otherPortal.y;
                        renderGameGrid();
                        showNotification('¬°Teletransportado!', 'info');
                        return;
                    }
                }
            }

            // Recolectar items
            collectItem(newIndex, tile);

            // Mover jugador
            gameState.player.x = newX;
            gameState.player.y = newY;

            renderGameGrid();
            updateHUD();
            checkZombieCollision();
            
            // Sincronizar en multijugador
            if (gameState.isMultiplayer && gameState.roomId) {
                updatePlayerPosition();
            }
        }

        function collectItem(index, tile) {
            switch(tile) {
                case TILE_TYPES.RIFLE:
                    gameState.ammo += 5;
                    gameState.inventory.rifles++;
                    gameState.weaponType = 'rifle';
                    gameState.shots = 10;
                    gameState.maxShots = 10;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showNotification('¬°Rifle encontrado! +5 munici√≥n', 'success');
                    updateHUD();
                    break;
                    
                case TILE_TYPES.SHOTGUN:
                    gameState.ammo += 3;
                    gameState.inventory.shotguns++;
                    gameState.weaponType = 'shotgun';
                    gameState.shots = 10;
                    gameState.maxShots = 10;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showNotification('¬°Shotgun encontrada! +3 munici√≥n', 'success');
                    updateHUD();
                    break;
                    
                case TILE_TYPES.KEY:
                    gameState.keys++;
                    gameState.inventory.keys++;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showNotification('¬°Llave encontrada!', 'success');
                    updateHUD();
                    break;
                    
                case TILE_TYPES.COIN:
                    gameState.coins++;
                    gameState.inventory.coins++;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    gameStats.playerCoins++;
                    gameStats.highscoreCoins = Math.max(gameStats.highscoreCoins, gameState.coins);
                    saveStats();
                    updateCoinsDisplay();
                    updateHUD();
                    showNotification('¬°Moneda recolectada!', 'success');
                    break;
                    
                case TILE_TYPES.BOMB:
                    gameState.bombs++;
                    gameState.inventory.bombs++;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showNotification('¬°Bomba encontrada!', 'success');
                    updateHUD();
                    break;
                    
                case TILE_TYPES.SWORD:
                    gameState.inventory.swords++;
                    gameState.weaponType = 'sword';
                    gameState.shots = 999;
                    gameState.maxShots = 999;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showNotification('¬°Espada encontrada!', 'success');
                    updateHUD();
                    break;
                    
                case TILE_TYPES.BULLET:
                    gameState.shots += 10;
                    if (gameState.maxShots > 0) {
                        gameState.shots = Math.min(gameState.shots, gameState.maxShots);
                    }
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showNotification('¬°Balas encontradas!', 'success');
                    updateHUD();
                    break;
                    
                case TILE_TYPES.AMMO:
                    gameState.ammo += 25;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    showNotification('¬°Munici√≥n encontrada!', 'success');
                    updateHUD();
                    break;
                    
                case TILE_TYPES.PALANCA:
                    for (let i = 0; i < gameState.grid.length; i++) {
                        if (gameState.grid[i] === TILE_TYPES.DOOR) {
                            gameState.grid[i] = TILE_TYPES.EXIT;
                        }
                    }
                    gameState.exitOpen = true;
                    gameState.exitOpenTimer = 20;
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    renderGameGrid();
                    showNotification('¬°Palanca activada! Puertas abiertas', 'success');
                    break;
                    
                case TILE_TYPES.VACUNA:
                    gameState.player.health = Math.min(
                        gameState.player.maxHealth, 
                        gameState.player.health + 50
                    );
                    gameState.grid[index] = TILE_TYPES.EMPTY;
                    updateHUD();
                    updateHealthBar();
                    showNotification('¬°Vacuna encontrada! +50 salud', 'success');
                    break;
            }
        }

        // ============================
        // SISTEMA DE ZOMBIS (M√ÅS LENTOS)
        // ============================
        function moveZombies() {
            if (!gameState.playing || gameState.paused) return;

            gameState.zombies.forEach(zombie => {
                const oldX = zombie.x;
                const oldY = zombie.y;
                
                let moveX = 0;
                let moveY = 0;
                
                // 70% de probabilidad de moverse hacia el jugador
                if (Math.random() < 0.7) {
                    moveX = Math.sign(gameState.player.x - zombie.x);
                    moveY = Math.sign(gameState.player.y - zombie.y);
                } else {
                    // Movimiento aleatorio
                    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    moveX = dir[0];
                    moveY = dir[1];
                }

                // Los zombis se mueven m√°s lentamente
                if (Math.random() < zombie.speed) {
                    let newX = zombie.x + moveX;
                    let newY = zombie.y + moveY;
                    
                    if (isValidMove(newX, newY, zombie)) {
                        zombie.x = newX;
                        zombie.y = newY;
                    }
                }

                // Verificar colisi√≥n con jugador
                if (zombie.x === gameState.player.x && zombie.y === gameState.player.y) {
                    handlePlayerHit(zombie);
                }
            });

            renderGameGrid();
        }

        function moveZombieRambos() {
            if (!gameState.playing || gameState.paused) return;

            gameState.zombieRambos.forEach(zombie => {
                const oldX = zombie.x;
                const oldY = zombie.y;
                
                let moveX = 0;
                let moveY = 0;
                
                // Zombie Rambos son m√°s inteligentes
                if (Math.random() < 0.8) {
                    moveX = Math.sign(gameState.player.x - zombie.x);
                    moveY = Math.sign(gameState.player.y - zombie.y);
                } else {
                    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    moveX = dir[0];
                    moveY = dir[1];
                }

                if (Math.random() < zombie.speed) {
                    let newX = zombie.x + moveX;
                    let newY = zombie.y + moveY;
                    
                    if (isValidMove(newX, newY, zombie)) {
                        zombie.x = newX;
                        zombie.y = newY;
                    }
                }

                // Disparar al jugador
                const currentTime = Date.now();
                if (currentTime - zombie.lastShotTime > zombie.shotCooldown) {
                    if (canShootPlayer(zombie.x, zombie.y, gameState.player.x, gameState.player.y)) {
                        zombieShoot(zombie);
                        zombie.lastShotTime = currentTime;
                    }
                }

                if (zombie.x === gameState.player.x && zombie.y === gameState.player.y) {
                    handlePlayerHit(zombie);
                }
            });

            renderGameGrid();
        }

        function isValidMove(x, y, entity) {
            if (x < 0 || x >= gameState.width || y < 0 || y >= gameState.height) {
                return false;
            }

            const index = y * gameState.width + x;
            const tile = gameState.grid[index];
            
            const blockingTiles = [
                TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.BOX,
                TILE_TYPES.EXIT, TILE_TYPES.DOOR, TILE_TYPES.START,
                TILE_TYPES.CACTUS, TILE_TYPES.WATER
            ];
            
            if (tile === TILE_TYPES.GRASS) {
                return false;
            }
            
            const zombieAtPos = gameState.zombies.find(z => z.x === x && z.y === y);
            const zombieRamboAtPos = gameState.zombieRambos.find(z => z.x === x && z.y === y);
            
            return !blockingTiles.includes(tile) && !zombieAtPos && !zombieRamboAtPos;
        }

        function canShootPlayer(fromX, fromY, toX, toY) {
            if (fromX === toX) {
                const step = fromY < toY ? 1 : -1;
                for (let y = fromY + step; y !== toY; y += step) {
                    const index = y * gameState.width + fromX;
                    const tile = gameState.grid[index];
                    if (tile !== TILE_TYPES.EMPTY && tile !== TILE_TYPES.GRASS) {
                        return false;
                    }
                }
                return true;
            } else if (fromY === toY) {
                const step = fromX < toX ? 1 : -1;
                for (let x = fromX + step; x !== toX; x += step) {
                    const index = fromY * gameState.width + x;
                    const tile = gameState.grid[index];
                    if (tile !== TILE_TYPES.EMPTY && tile !== TILE_TYPES.GRASS) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        function zombieShoot(zombie) {
            applyDamage(20);
            showNotification('¬°Zombie Rambo te ha disparado!', 'error');
        }

        function handlePlayerHit(zombie) {
            const damage = zombie ? (zombie.speed === 0.8 ? 20 : 10) : 10;
            applyDamage(damage);
            showNotification('¬°Zombie te ha atacado!', 'error');
        }

        function applyDamage(damage) {
            gameState.player.health -= damage;
            updateHUD();
            updateHealthBar();
            
            if (gameState.player.health <= 0) {
                endGame(false, '¬°Has sido derrotado!');
            }
        }

        function checkZombieCollision() {
            const zombieCollision = gameState.zombies.some(z => 
                z.x === gameState.player.x && z.y === gameState.player.y
            );
            
            const zombieRamboCollision = gameState.zombieRambos.some(z => 
                z.x === gameState.player.x && z.y === gameState.player.y
            );
            
            if (zombieCollision || zombieRamboCollision) {
                handlePlayerHit(zombieCollision ? gameState.zombies[0] : gameState.zombieRambos[0]);
            }
        }

        // ============================
        // SISTEMA DE ATAQUE
        // ============================
        function attack() {
            if (!gameState.playing || gameState.paused) return;
            
            if (gameState.weaponType === null) {
                showNotification('No tienes un arma equipada', 'error');
                return;
            }

            if (gameState.weaponType === 'sword') {
                swordAttack();
                return;
            }

            if (gameState.shots <= 0) {
                if (gameState.ammo > 0) {
                    gameState.shots = gameState.maxShots;
                    gameState.ammo--;
                    updateHUD();
                } else {
                    showNotification('Sin munici√≥n', 'error');
                    return;
                }
            }

            gameState.shots--;
            
            if (gameState.weaponType === 'rifle') {
                rifleAttack();
            } else if (gameState.weaponType === 'shotgun') {
                shotgunAttack();
            }

            updateHUD();
            renderGameGrid();
        }

        function rifleAttack() {
            const directions = [
                {dx: 1, dy: 0},
                {dx: -1, dy: 0},
                {dx: 0, dy: 1},
                {dx: 0, dy: -1}
            ];

            let zombiesKilled = 0;

            directions.forEach(dir => {
                let x = gameState.player.x + dir.dx;
                let y = gameState.player.y + dir.dy;
                
                while (x >= 0 && x < gameState.width && y >= 0 && y < gameState.height) {
                    const index = y * gameState.width + x;
                    const tile = gameState.grid[index];
                    
                    if ([TILE_TYPES.BOX, TILE_TYPES.CACTUS, TILE_TYPES.GRASS].includes(tile)) {
                        gameState.grid[index] = TILE_TYPES.EMPTY;
                        break;
                    }
                    
                    if ([TILE_TYPES.WALL, TILE_TYPES.ROCK, TILE_TYPES.EXIT, TILE_TYPES.DOOR, TILE_TYPES.START].includes(tile)) {
                        break;
                    }
                    
                    const zombieIndex = gameState.zombies.findIndex(z => z.x === x && z.y === y);
                    if (zombieIndex !== -1) {
                        gameState.zombies.splice(zombieIndex, 1);
                        zombiesKilled++;
                        break;
                    }
                    
                    const zombieRamboIndex = gameState.zombieRambos.findIndex(z => z.x === x && z.y === y);
                    if (zombieRamboIndex !== -1) {
                        gameState.zombieRambos.splice(zombieRamboIndex, 1);
                        zombiesKilled++;
                        break;
                    }
                    
                    x += dir.dx;
                    y += dir.dy;
                }
            });

            if (zombiesKilled > 0) {
                gameStats.totalZombies += zombiesKilled;
                saveStats();
                showNotification(`¬°${zombiesKilled} zombi(s) eliminado(s)!`, 'success');
            }
        }

        function shotgunAttack() {
            let zombiesKilled = 0;
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const x = gameState.player.x + dx;
                    const y = gameState.player.y + dy;
                    
                    if (x >= 0 && x < gameState.width && y >= 0 && y < gameState.height) {
                        const index = y * gameState.width + x;
                        const tile = gameState.grid[index];
                        
                        if ([TILE_TYPES.BOX, TILE_TYPES.CACTUS, TILE_TYPES.GRASS].includes(tile)) {
                            gameState.grid[index] = TILE_TYPES.EMPTY;
                        }
                        
                        const zombieIndex = gameState.zombies.findIndex(z => z.x === x && z.y === y);
                        if (zombieIndex !== -1) {
                            gameState.zombies.splice(zombieIndex, 1);
                            zombiesKilled++;
                        }
                        
                        const zombieRamboIndex = gameState.zombieRambos.findIndex(z => z.x === x && z.y === y);
                        if (zombieRamboIndex !== -1) {
                            gameState.zombieRambos.splice(zombieRamboIndex, 1);
                            zombiesKilled++;
                        }
                    }
                }
            }

            if (zombiesKilled > 0) {
                gameStats.totalZombies += zombiesKilled;
                saveStats();
                showNotification(`¬°${zombiesKilled} zombi(s) eliminado(s)!`, 'success');
            }
        }

        function swordAttack() {
            const directions = [
                {dx: 1, dy: 0},
                {dx: -1, dy: 0},
                {dx: 0, dy: 1},
                {dx: 0, dy: -1}
            ];
            
            let zombiesKilled = 0;
            
            directions.forEach(dir => {
                const x = gameState.player.x + dir.dx;
                const y = gameState.player.y + dir.dy;
                
                if (x >= 0 && x < gameState.width && y >= 0 && y < gameState.height) {
                    const index = y * gameState.width + x;
                    const tile = gameState.grid[index];
                    
                    if ([TILE_TYPES.BOX, TILE_TYPES.CACTUS, TILE_TYPES.GRASS].includes(tile)) {
                        gameState.grid[index] = TILE_TYPES.EMPTY;
                    }
                    
                    const zombieIndex = gameState.zombies.findIndex(z => z.x === x && z.y === y);
                    if (zombieIndex !== -1) {
                        gameState.zombies.splice(zombieIndex, 1);
                        zombiesKilled++;
                    }
                    
                    const zombieRamboIndex = gameState.zombieRambos.findIndex(z => z.x === x && z.y === y);
                    if (zombieRamboIndex !== -1) {
                        gameState.zombieRambos.splice(zombieRamboIndex, 1);
                        zombiesKilled++;
                    }
                }
            });

            if (zombiesKilled > 0) {
                gameStats.totalZombies += zombiesKilled;
                saveStats();
                showNotification(`¬°${zombiesKilled} zombi(s) eliminado(s)!`, 'success');
            }
        }

        // ============================
        // SISTEMA DE BOMBAS
        // ============================
        function useBomb() {
            if (gameState.bombs <= 0) {
                showNotification('No tienes bombas', 'error');
                return;
            }
            
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) {
                bombSelector.classList.add('active');
            }
        }

        function placeBomb() {
            if (gameState.bombs <= 0) return;
            
            gameState.bombs--;
            gameState.inventory.bombs--;
            
            const bomb = {
                x: gameState.player.x,
                y: gameState.player.y,
                timer: 5
            };
            
            gameState.activeBombs.push(bomb);
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) {
                bombSelector.classList.remove('active');
            }
            showNotification('¬°Bomba colocada! Explotar√° en 5 segundos', 'info');
            updateHUD();
            renderGameGrid();
        }

        function updateBombs() {
            if (!gameState.playing || gameState.paused) return;
            
            for (let i = gameState.activeBombs.length - 1; i >= 0; i--) {
                const bomb = gameState.activeBombs[i];
                bomb.timer--;
                
                if (bomb.timer <= 0) {
                    explodeBomb(bomb.x, bomb.y);
                    gameState.activeBombs.splice(i, 1);
                }
            }
        }

        function explodeBomb(x, y) {
            let zombiesKilled = 0;
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX >= 0 && newX < gameState.width && newY >= 0 && newY < gameState.height) {
                        const index = newY * gameState.width + newX;
                        const tile = gameState.grid[index];
                        
                        if (![TILE_TYPES.ROCK, TILE_TYPES.START, TILE_TYPES.EXIT, TILE_TYPES.DOOR].includes(tile)) {
                            gameState.grid[index] = TILE_TYPES.EMPTY;
                        }
                        
                        const zombieIndex = gameState.zombies.findIndex(z => z.x === newX && z.y === newY);
                        if (zombieIndex !== -1) {
                            gameState.zombies.splice(zombieIndex, 1);
                            zombiesKilled++;
                        }
                        
                        const zombieRamboIndex = gameState.zombieRambos.findIndex(z => z.x === newX && z.y === newY);
                        if (zombieRamboIndex !== -1) {
                            gameState.zombieRambos.splice(zombieRamboIndex, 1);
                            zombiesKilled++;
                        }
                        
                        if (newX === gameState.player.x && newY === gameState.player.y) {
                            applyDamage(30);
                            showNotification('¬°Te ha afectado la explosi√≥n!', 'error');
                        }
                    }
                }
            }
            
            if (zombiesKilled > 0) {
                gameStats.totalZombies += zombiesKilled;
                saveStats();
                showNotification(`¬°Bomba explot√≥! ${zombiesKilled} zombi(s) eliminado(s)`, 'success');
            }
            
            renderGameGrid();
        }

        function cancelBomb() {
            const bombSelector = document.getElementById('bomb-selector');
            if (bombSelector) {
                bombSelector.classList.remove('active');
            }
        }

        // ============================
        // INVENTARIO
        // ============================
        function toggleInventory() {
            const modal = document.getElementById('inventory-modal');
            if (!modal) return;
            
            modal.classList.toggle('active');
            
            if (modal.classList.contains('active')) {
                updateInventoryDisplay();
            }
        }

        function updateInventoryDisplay() {
            const container = document.getElementById('inventory-items');
            if (!container) return;
            
            container.innerHTML = '';
            
            const items = [
                { key: 'rifles', name: 'Rifles', count: gameState.inventory.rifles, icon: 'rifle.png' },
                { key: 'shotguns', name: 'Shotguns', count: gameState.inventory.shotguns, icon: 'shotgun.png' },
                { key: 'swords', name: 'Espadas', count: gameState.inventory.swords, icon: 'espada.png' },
                { key: 'keys', name: 'Llaves', count: gameState.inventory.keys, icon: 'llave.png' },
                { key: 'coins', name: 'Monedas', count: gameState.inventory.coins, icon: 'moneda.png' },
                { key: 'bombs', name: 'Bombas', count: gameState.inventory.bombs, icon: 'bomba.png' },
                { key: 'bullets', name: 'Balas', count: gameState.inventory.bullets, icon: 'balas.png' },
                { key: 'ammo', name: 'Munici√≥n', count: gameState.ammo, icon: 'municiones.png' }
            ];
            
            items.forEach(item => {
                if (item.count > 0 || (item.key === 'ammo' && gameState.ammo > 0)) {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'inventory-item';
                    itemEl.innerHTML = `
                        <div class="item-icon" style="background-image: url('${item.icon}')"></div>
                        <div class="item-count">${item.key === 'ammo' ? gameState.ammo : item.count}</div>
                        <div class="item-name">${item.name}</div>
                    `;
                    
                    if (item.key === 'bombs' && item.count > 0) {
                        itemEl.style.cursor = 'pointer';
                        itemEl.onclick = () => useBomb();
                        itemEl.title = 'Haz clic para usar bomba';
                    }
                    
                    container.appendChild(itemEl);
                }
            });
            
            if (container.children.length === 0) {
                container.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #94a3b8;">Inventario vac√≠o</p>';
            }
        }

        // ============================
        // SISTEMA DE JUEGO
        // ============================
        function gameLoop() {
            if (!gameState.playing || gameState.paused) return;

            gameState.time--;
            updateHUD();

            if (gameState.time <= 0) {
                endGame(false, '¬°Se acab√≥ el tiempo!');
                return;
            }

            if (gameState.exitOpen && gameState.exitOpenTimer > 0) {
                gameState.exitOpenTimer--;
                if (gameState.exitOpenTimer <= 0) {
                    gameState.exitOpen = false;
                    for (let i = 0; i < gameState.grid.length; i++) {
                        if (gameState.grid[i] === TILE_TYPES.EXIT) {
                            gameState.grid[i] = TILE_TYPES.DOOR;
                        }
                    }
                    renderGameGrid();
                    showNotification('¬°Las puertas se han cerrado!', 'warning');
                }
            }

            const playerIndex = gameState.player.y * gameState.width + gameState.player.x;
            const tileAtPlayer = gameState.grid[playerIndex];
            
            if (tileAtPlayer === TILE_TYPES.EXIT) {
                endGame(true, '¬°Has completado el nivel!');
            } else if (tileAtPlayer === TILE_TYPES.DOOR) {
                if (gameState.keys > 0) {
                    gameState.keys--;
                    gameState.grid[playerIndex] = TILE_TYPES.EXIT;
                    updateHUD();
                    renderGameGrid();
                    showNotification('¬°Puerta abierta con llave!', 'success');
                }
            }
        }

        function updateExitTimer() {
            if (gameState.exitOpenTimer > 0) {
                gameState.exitOpenTimer--;
            }
        }

        // ============================
        // SISTEMA DE PAUSA
        // ============================
        function togglePause() {
            if (!gameState.playing) return;
            
            gameState.paused = !gameState.paused;
            const pauseOverlay = document.getElementById('pause-overlay');
            
            if (pauseOverlay) {
                if (gameState.paused) {
                    pauseOverlay.style.display = 'flex';
                } else {
                    pauseOverlay.style.display = 'none';
                }
            }
        }

        function resumeGame() {
            gameState.paused = false;
            const pauseOverlay = document.getElementById('pause-overlay');
            if (pauseOverlay) {
                pauseOverlay.style.display = 'none';
            }
        }

        // ============================
        // FIN DEL JUEGO
        // ============================
        async function endGame(won, message) {
            gameState.playing = false;
            clearInterval(gameState.timer);
            clearInterval(gameState.zombieTimer);
            if (gameState.zombieRamboTimer) clearInterval(gameState.zombieRamboTimer);
            if (gameState.bombTimer) clearInterval(gameState.bombTimer);
            if (gameState.exitTimer) clearInterval(gameState.exitTimer);
            
            if (shootInterval) {
                clearInterval(shootInterval);
                shootInterval = null;
            }

            // Salir de la sala multijugador si existe
            if (gameState.isMultiplayer && gameState.roomId) {
                leaveMultiplayerRoom();
            }

            if (won) {
                gameStats.totalLevels++;
                const coinsEarned = 10 + (currentLevelIndex + 1) * 5;
                gameStats.playerCoins += coinsEarned;
                
                if (currentLevelIndex !== -1) {
                    currentLevelIndex++;
                    
                    const progress = {
                        currentLevel: currentLevelIndex + 1,
                        totalLevels: gameStats.totalLevels,
                        playerCoins: gameStats.playerCoins
                    };
                    localStorage.setItem('sandboxProgress', JSON.stringify(progress));
                }
                
                saveStats();
                
                const score = gameState.coins * 100 + gameState.time * 10;
                await submitHighscore(score, currentLevel ? currentLevel.levelNumber : 1, selectedCharacter.name);
            }

            showMessage(
                won ? '¬°VICTORIA!' : '¬°GAME OVER!',
                `${message}<br><br>Personaje: ${selectedCharacter.name}<br>Salud restante: ${gameState.player.health}/${gameState.player.maxHealth}<br>Monedas recolectadas: ${gameState.coins}<br>Monedas totales: ${gameStats.playerCoins}`,
                0
            );

            const messageButton = document.getElementById('message-button');
            if (messageButton) {
                messageButton.onclick = () => {
                    hideMessage();
                    if (won) {
                        if (currentLevelIndex !== -1 && currentLevelIndex < savedLevels.length) {
                            currentLevel = savedLevels[currentLevelIndex];
                            startGame();
                        } else {
                            showNotification('¬°Felicidades! Has completado el nivel. ¬°Eres un h√©roe!', 'success');
                            setTimeout(() => showScreen('main-menu'), 3000);
                        }
                    } else {
                        startGame();
                    }
                };
            }
        }

        // ============================
        // CONTROLES DE TECLADO
        // ============================
        function handleKeyPress(e) {
            if (currentScreen !== 'game-screen' || !gameState.playing) return;

            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayer(1, 0);
                    break;
                case ' ':
                case 'Spacebar':
                    attack();
                    break;
                case 'b':
                case 'B':
                    useBomb();
                    break;
                case 'i':
                case 'I':
                    toggleInventory();
                    break;
                case 'p':
                case 'P':
                case 'Escape':
                    togglePause();
                    break;
                case 'f':
                case 'F':
                    toggleFullscreen();
                    break;
            }
        }

        // ============================
        // SISTEMA DE MENSAJES
        // ============================
        function showMessage(title, text, autoHide = 3000) {
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const messageModal = document.getElementById('message-modal');
            
            if (!messageTitle || !messageText || !messageModal) return;
            
            messageTitle.textContent = title;
            messageText.innerHTML = text;
            messageModal.classList.add('active');

            if (autoHide > 0) {
                setTimeout(hideMessage, autoHide);
            }
        }

        function hideMessage() {
            const messageModal = document.getElementById('message-modal');
            const levelsModal = document.getElementById('levels-modal');
            
            if (messageModal) messageModal.classList.remove('active');
            if (levelsModal) levelsModal.classList.remove('active');
        }

        // ============================
        // SISTEMA DE CLICS EN EL T√çTULO
        // ============================
        let titleClickCount = 0;
        
        function countTitleClicks() {
            titleClickCount++;
            
            if (titleClickCount >= 10) {
                showNotification('¬°Easter Egg encontrado! ¬°Sigue as√≠!', 'success');
                titleClickCount = 0;
            }
        }

        // ============================
        // SISTEMA DE NIVEL POR DEFECTO
        // ============================
        function createDefaultLevel() {
            const defaultGrid = Array(100).fill(TILE_TYPES.EMPTY);
            
            // Paredes alrededor
            for (let i = 0; i < 10; i++) {
                defaultGrid[i] = TILE_TYPES.WALL; // Top
                defaultGrid[90 + i] = TILE_TYPES.WALL; // Bottom
                defaultGrid[i * 10] = TILE_TYPES.WALL; // Left
                defaultGrid[i * 10 + 9] = TILE_TYPES.WALL; // Right
            }
            
            // Entrada
            defaultGrid[11] = TILE_TYPES.START;
            
            // Salida
            defaultGrid[88] = TILE_TYPES.EXIT;
            
            // Obst√°culos
            defaultGrid[22] = TILE_TYPES.ROCK;
            defaultGrid[23] = TILE_TYPES.BOX;
            defaultGrid[33] = TILE_TYPES.WATER;
            defaultGrid[34] = TILE_TYPES.WATER;
            defaultGrid[45] = TILE_TYPES.CACTUS;
            
            // Zombies
            defaultGrid[44] = TILE_TYPES.ZOMBIE;
            defaultGrid[55] = TILE_TYPES.ZOMBIE;
            defaultGrid[66] = TILE_TYPES.ZOMBIE_RAMBO;
            
            // Items
            defaultGrid[35] = TILE_TYPES.RIFLE;
            defaultGrid[46] = TILE_TYPES.SHOTGUN;
            defaultGrid[57] = TILE_TYPES.KEY;
            defaultGrid[68] = TILE_TYPES.COIN;
            defaultGrid[79] = TILE_TYPES.BOMB;
            defaultGrid[25] = TILE_TYPES.SWORD;
            defaultGrid[36] = TILE_TYPES.BULLET;
            defaultGrid[47] = TILE_TYPES.AMMO;
            defaultGrid[58] = TILE_TYPES.PALANCA;
            defaultGrid[69] = TILE_TYPES.VACUNA;
            
            // Portal
            defaultGrid[26] = TILE_TYPES.PORTAL;
            defaultGrid[86] = TILE_TYPES.PORTAL;

            const defaultLevel = {
                name: 'Nivel 1 - El Comienzo',
                width: 10,
                height: 10,
                timeLimit: 180,
                levelNumber: 1,
                levelType: 'default',
                grid: defaultGrid
            };
            
            savedLevels.push(defaultLevel);
            localStorage.setItem('sandboxLevels', JSON.stringify(savedLevels));
        }

        // ============================
        // SISTEMA MULTIJUGADOR
        // ============================
        async function loadMultiplayerRooms() {
            try {
                const snapshot = await db.collection('multiplayer_rooms')
                    .where('status', '==', 'waiting')
                    .get();
                
                multiplayerRooms = [];
                snapshot.forEach(doc => {
                    multiplayerRooms.push({ id: doc.id, ...doc.data() });
                });
                
                updateRoomsDisplay();
            } catch (error) {
                console.error('Error cargando salas:', error);
            }
        }

        function updateRoomsDisplay() {
            const roomsContainer = document.getElementById('multiplayer-rooms');
            const noRoomsMessage = document.getElementById('no-rooms-message');
            
            if (!roomsContainer || !noRoomsMessage) return;
            
            roomsContainer.innerHTML = '';
            
            if (multiplayerRooms.length === 0) {
                noRoomsMessage.style.display = 'block';
                return;
            }
            
            noRoomsMessage.style.display = 'none';
            
            multiplayerRooms.forEach(room => {
                const roomCard = document.createElement('div');
                roomCard.className = `room-card ${room.players.length >= room.maxPlayers ? 'full' : ''}`;
                
                const playersHtml = Array(room.maxPlayers).fill().map((_, index) => {
                    const player = room.players[index];
                    return `
                        <div class="player-slot ${player ? 'occupied' : ''}">
                            ${player ? player.name.charAt(0).toUpperCase() : '+'}
                        </div>
                    `;
                }).join('');
                
                roomCard.innerHTML = `
                    <div class="room-header">
                        <h3 style="color: var(--accent);">${room.name}</h3>
                        <span style="color: #94a3b8; font-size: 0.9rem;">${room.players.length}/${room.maxPlayers}</span>
                    </div>
                    <div class="room-players">
                        ${playersHtml}
                    </div>
                    <div class="room-info">
                        <span style="color: #94a3b8; font-size: 0.9rem;">${room.levelName}</span>
                        <button class="btn btn-primary" onclick="joinMultiplayerRoom('${room.id}')" 
                                ${room.players.length >= room.maxPlayers ? 'disabled' : ''}
                                style="padding: 0.5rem 1rem; font-size: 0.9rem;">
                            <i class="fas fa-gamepad"></i> Unirse
                        </button>
                    </div>
                `;
                
                roomsContainer.appendChild(roomCard);
            });
        }

        function refreshRooms() {
            loadMultiplayerRooms();
            showNotification('Salas actualizadas', 'info');
        }

        async function createMultiplayerRoom() {
            if (!selectedCharacter) {
                showNotification('Debes seleccionar un personaje primero', 'error');
                return;
            }
            
            if (selectedCharacter.premium && !gameStats.unlockedCharacters.includes(selectedCharacter.id)) {
                showNotification(`¬°${selectedCharacter.name} est√° bloqueado!`, 'error');
                return;
            }
            
            showRoomModal('create');
        }

        function showRoomModal(mode, room = null) {
            const modal = document.getElementById('room-modal');
            const title = document.getElementById('room-title');
            const roomNameInput = document.getElementById('room-name-input');
            const levelSelect = document.getElementById('room-level-select');
            const maxPlayersSelect = document.getElementById('room-max-players');
            const startBtn = document.getElementById('start-room-btn');
            const leaveBtn = document.getElementById('leave-room-btn');
            
            if (!modal || !title || !roomNameInput || !levelSelect) return;
            
            // Configurar t√≠tulo
            title.textContent = mode === 'create' ? 'Crear Sala' : `Sala: ${room?.name || ''}`;
            
            // Cargar niveles en el selector
            levelSelect.innerHTML = '';
            savedLevels.forEach((level, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${level.name} (${level.width}x${level.height})`;
                levelSelect.appendChild(option);
            });
            
            // Configurar inputs seg√∫n el modo
            if (mode === 'create') {
                roomNameInput.value = `Sala de ${gameStats.playerName}`;
                roomNameInput.disabled = false;
                levelSelect.disabled = false;
                maxPlayersSelect.disabled = false;
                startBtn.style.display = 'inline-block';
                leaveBtn.textContent = 'Cancelar';
            } else {
                roomNameInput.value = room.name;
                roomNameInput.disabled = true;
                levelSelect.value = room.levelIndex;
                levelSelect.disabled = true;
                maxPlayersSelect.value = room.maxPlayers;
                maxPlayersSelect.disabled = true;
                startBtn.style.display = room.hostId === gameStats.playerId ? 'inline-block' : 'none';
                leaveBtn.textContent = 'Salir';
            }
            
            // Actualizar lista de jugadores
            updateRoomPlayersList(room?.players || []);
            
            modal.classList.add('active');
        }

        function updateRoomPlayersList(players) {
            const playersList = document.getElementById('room-players-list');
            if (!playersList) return;
            
            playersList.innerHTML = '<h4 style="color: var(--accent); margin-bottom: 1rem;">Jugadores:</h4>';
            
            if (players.length === 0) {
                playersList.innerHTML += '<p style="color: #94a3b8;">No hay jugadores en la sala</p>';
                return;
            }
            
            players.forEach((player, index) => {
                const playerEl = document.createElement('div');
                playerEl.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    padding: 0.75rem;
                    background: rgba(30, 41, 59, 0.5);
                    border-radius: 8px;
                    margin-bottom: 0.5rem;
                `;
                
                playerEl.innerHTML = `
                    <div class="player-color" style="width: 20px; height: 20px; border-radius: 50%; background: var(--player${index + 1});"></div>
                    <span style="font-weight: ${player.id === gameStats.playerId ? 'bold' : 'normal'}; color: ${player.id === gameStats.playerId ? 'var(--accent)' : 'white'}">
                        ${player.name} ${player.id === gameStats.playerId ? '(T√∫)' : ''}
                    </span>
                    ${player.host ? '<span style="color: var(--accent); margin-left: auto;">üëë</span>' : ''}
                `;
                
                playersList.appendChild(playerEl);
            });
        }

        async function startMultiplayerGame() {
            const roomNameInput = document.getElementById('room-name-input');
            const levelSelect = document.getElementById('room-level-select');
            const maxPlayersSelect = document.getElementById('room-max-players');
            
            if (!roomNameInput || !levelSelect) return;
            
            const roomName = roomNameInput.value.trim();
            const levelIndex = parseInt(levelSelect.value);
            const maxPlayers = parseInt(maxPlayersSelect.value);
            
            if (!roomName) {
                showNotification('Ingresa un nombre para la sala', 'error');
                return;
            }
            
            if (levelIndex < 0 || levelIndex >= savedLevels.length) {
                showNotification('Selecciona un nivel v√°lido', 'error');
                return;
            }
            
            showLoading('Creando sala...');
            
            try {
                // Crear sala en Firebase
                const roomRef = await db.collection('multiplayer_rooms').add({
                    name: roomName,
                    hostId: gameStats.playerId,
                    hostName: gameStats.playerName,
                    levelIndex: levelIndex,
                    levelName: savedLevels[levelIndex].name,
                    maxPlayers: maxPlayers,
                    players: [{
                        id: gameStats.playerId,
                        name: gameStats.playerName,
                        character: selectedCharacter.id,
                        host: true,
                        ready: true
                    }],
                    status: 'waiting',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                currentRoom = {
                    id: roomRef.id,
                    name: roomName,
                    hostId: gameStats.playerId,
                    levelIndex: levelIndex,
                    maxPlayers: maxPlayers,
                    players: [{
                        id: gameStats.playerId,
                        name: gameStats.playerName,
                        character: selectedCharacter.id,
                        host: true,
                        ready: true
                    }]
                };
                
                // Escuchar cambios en la sala
                setupRoomListener(roomRef.id);
                
                hideRoomModal();
                showNotification('¬°Sala creada! Esperando jugadores...', 'success');
                
            } catch (error) {
                console.error('Error creando sala:', error);
                showNotification('Error al crear la sala', 'error');
                hideLoading();
            }
        }

        async function joinMultiplayerRoom(roomId) {
            if (!selectedCharacter) {
                showNotification('Debes seleccionar un personaje primero', 'error');
                return;
            }
            
            showLoading('Uni√©ndose a la sala...');
            
            try {
                const roomRef = db.collection('multiplayer_rooms').doc(roomId);
                const roomDoc = await roomRef.get();
                
                if (!roomDoc.exists) {
                    showNotification('La sala ya no existe', 'error');
                    hideLoading();
                    return;
                }
                
                const room = roomDoc.data();
                
                if (room.players.length >= room.maxPlayers) {
                    showNotification('La sala est√° llena', 'error');
                    hideLoading();
                    return;
                }
                
                // Agregar jugador a la sala
                await roomRef.update({
                    players: firebase.firestore.FieldValue.arrayUnion({
                        id: gameStats.playerId,
                        name: gameStats.playerName,
                        character: selectedCharacter.id,
                        host: false,
                        ready: true
                    })
                });
                
                currentRoom = {
                    id: roomId,
                    name: room.name,
                    hostId: room.hostId,
                    levelIndex: room.levelIndex,
                    maxPlayers: room.maxPlayers,
                    players: [...room.players, {
                        id: gameStats.playerId,
                        name: gameStats.playerName,
                        character: selectedCharacter.id,
                        host: false,
                        ready: true
                    }]
                };
                
                // Escuchar cambios en la sala
                setupRoomListener(roomId);
                
                hideLoading();
                showRoomModal('join', currentRoom);
                
            } catch (error) {
                console.error('Error uni√©ndose a la sala:', error);
                showNotification('Error al unirse a la sala', 'error');
                hideLoading();
            }
        }

        function setupRoomListener(roomId) {
            // Limpiar listener anterior
            if (roomListener) {
                roomListener();
            }
            
            roomListener = db.collection('multiplayer_rooms').doc(roomId)
                .onSnapshot((doc) => {
                    if (!doc.exists) {
                        showNotification('La sala ha sido eliminada', 'error');
                        leaveRoom();
                        return;
                    }
                    
                    const room = doc.data();
                    currentRoom = { id: doc.id, ...room };
                    
                    // Actualizar vista de la sala
                    if (document.getElementById('room-modal').classList.contains('active')) {
                        updateRoomPlayersList(room.players);
                        
                        // Si el host inici√≥ el juego
                        if (room.status === 'playing') {
                            hideRoomModal();
                            startMultiplayerGameSession(room);
                        }
                    }
                    
                    // Si el host abandon√≥ la sala
                    if (room.players.length === 0) {
                        showNotification('El host ha abandonado la sala', 'error');
                        leaveRoom();
                    }
                }, (error) => {
                    console.error('Error en listener de sala:', error);
                });
        }

        async function startMultiplayerGameSession(room) {
            // Cargar nivel
            currentLevelIndex = room.levelIndex;
            currentLevel = savedLevels[currentLevelIndex];
            
            // Configurar juego multijugador
            gameState.isMultiplayer = true;
            gameState.roomId = room.id;
            gameState.multiplayerPlayers = {};
            
            // Iniciar juego
            showScreen('game-screen');
            
            // Configurar listener de juego
            setupGameListener(room.id);
        }

        function setupGameListener(roomId) {
            // Configurar listener para actualizaciones de otros jugadores
            if (gameListener) {
                gameListener();
            }
            
            gameListener = db.collection('multiplayer_games').doc(roomId)
                .collection('players')
                .onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const playerData = change.doc.data();
                            if (playerData.playerId !== gameStats.playerId) {
                                updateOtherPlayer(playerData);
                            }
                        } else if (change.type === 'removed') {
                            const playerId = change.doc.id;
                            removeOtherPlayer(playerId);
                        }
                    });
                });
        }

        function updatePlayerPosition() {
            if (!gameState.isMultiplayer || !gameState.roomId) return;
            
            const playerRef = db.collection('multiplayer_games').doc(gameState.roomId)
                .collection('players').doc(gameStats.playerId);
            
            playerRef.set({
                playerId: gameStats.playerId,
                playerName: gameStats.playerName,
                character: selectedCharacter.id,
                x: gameState.player.x,
                y: gameState.player.y,
                health: gameState.player.health,
                maxHealth: gameState.player.maxHealth,
                coins: gameState.coins,
                lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
            });
        }

        function updateOtherPlayer(playerData) {
            // Actualizar o agregar jugador en el estado del juego
            const existingIndex = gameState.otherPlayers.findIndex(p => p.playerId === playerData.playerId);
            
            if (existingIndex !== -1) {
                gameState.otherPlayers[existingIndex] = {
                    ...gameState.otherPlayers[existingIndex],
                    x: playerData.x,
                    y: playerData.y,
                    health: playerData.health,
                    maxHealth: playerData.maxHealth
                };
            } else {
                gameState.otherPlayers.push({
                    playerId: playerData.playerId,
                    name: playerData.playerName,
                    character: playerData.character,
                    x: playerData.x,
                    y: playerData.y,
                    health: playerData.health,
                    maxHealth: playerData.maxHealth,
                    image: CHARACTERS.find(c => c.id === playerData.character)?.image || 'civil.png',
                    color: `var(--player${gameState.otherPlayers.length + 2})`
                });
                
                // Actualizar HUD multijugador
                updateMultiplayerHUD();
            }
            
            renderGameGrid();
        }

        function removeOtherPlayer(playerId) {
            gameState.otherPlayers = gameState.otherPlayers.filter(p => p.playerId !== playerId);
            updateMultiplayerHUD();
            renderGameGrid();
            showNotification('Un jugador ha abandonado la partida', 'info');
        }

        function updateMultiplayerHUD() {
            const multiplayerHUD = document.getElementById('multiplayer-hud');
            if (!multiplayerHUD) return;
            
            multiplayerHUD.style.display = 'flex';
            multiplayerHUD.innerHTML = `
                <i class="fas fa-users" style="color: var(--player1);"></i>
                <div class="player-indicator player-1">
                    <div class="player-color"></div>
                    <span class="hud-value">${gameStats.playerName}</span>
                </div>
            `;
            
            gameState.otherPlayers.forEach((player, index) => {
                const playerEl = document.createElement('div');
                playerEl.className = `player-indicator player-${index + 2}`;
                playerEl.innerHTML = `
                    <div class="player-color"></div>
                    <span class="hud-value">${player.name}</span>
                `;
                multiplayerHUD.appendChild(playerEl);
            });
        }

        async function leaveRoom() {
            if (currentRoom && gameState.roomId) {
                try {
                    // Remover jugador de la sala
                    const roomRef = db.collection('multiplayer_rooms').doc(currentRoom.id);
                    await roomRef.update({
                        players: firebase.firestore.FieldValue.arrayRemove({
                            id: gameStats.playerId,
                            name: gameStats.playerName
                        })
                    });
                    
                    // Si el jugador era el host y la sala queda vac√≠a, eliminar sala
                    if (currentRoom.hostId === gameStats.playerId) {
                        const roomDoc = await roomRef.get();
                        if (roomDoc.exists && roomDoc.data().players.length === 0) {
                            await roomRef.delete();
                        }
                    }
                    
                } catch (error) {
                    console.error('Error saliendo de la sala:', error);
                }
            }
            
            // Limpiar listeners
            if (roomListener) {
                roomListener();
                roomListener = null;
            }
            
            if (gameListener) {
                gameListener();
                gameListener = null;
            }
            
            // Resetear estado
            currentRoom = null;
            gameState.isMultiplayer = false;
            gameState.roomId = null;
            gameState.otherPlayers = [];
            
            hideRoomModal();
            showNotification('Has abandonado la sala', 'info');
        }

        function leaveMultiplayerRoom() {
            leaveRoom();
        }

        function hideRoomModal() {
            const modal = document.getElementById('room-modal');
            if (modal) {
                modal.classList.remove('active');
            }
            hideLoading();
        }

        // ============================
        // SISTEMA DE PANTALLA COMPLETA
        // ============================
        function setupFullscreen() {
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        function handleFullscreenChange() {
            isFullscreen = !!(document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement);
        }

        function toggleFullscreen() {
            const element = document.documentElement;
            
            if (!isFullscreen) {
                if (element.requestFullscreen) {
                    element.requestFullscreen();
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
                showNotification('Pantalla completa activada', 'info');
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                showNotification('Pantalla completa desactivada', 'info');
            }
        }
    </script>
</body>
</html>
